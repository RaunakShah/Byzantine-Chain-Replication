import nacl.encoding
import nacl.signing
import re

class Olympus(process):
	def setup(config, client_verify_key_list, olympus_signing_key):
		self.replica_num = int(config['t'])
		self.replica_num = replica_num * 2 + 1
		self.head_timeout = int(config['head_timeout'])
		self.nonhead_timeout = int(config['nonhead_timeout'])
		self.client_num = int(config['num_client'])
		self.configuration_id = 0
		
		# create replicas
		replica_da = import_da('replica')
		self.replicas = new(replica_da.Replica, num = self.replica_num)
		self.replica_list = []
		self.signing_key_list = []
		self.verify_key_list = []	
		# put replicas to a list, and create signing key and verify key for each replica
		for replica in self.replicas:
			self.replica_list.append(replica)	
			replica_signing_key = nacl.signing.SigningKey.generate()
			replica_verify_key = replica_signing_key.verify_key
			replica_verify_key_hex = replica_verify_key.encode(encoder = nacl.encoding.HexEncoder)
			self.verify_key_list.append(replica_verify_key_hex)
			self.signing_key_list.append(replica_signing_key)
		
		# setup each replica
		for index in range(len(replica_list)):
			replica = replica_list[index]
			isHead = False
			isTail = False
			prev_replica = None
			next_replica = None
			timeout = self.nonhead_timeout

			failures = dict()
			if 'failures[' + str(self.configuration_id) + ',' + str(index) + ']' in config:
				fail_trig_unparsed = config['failures[' + str(self.configuration_id) + ',' + str(index) + ']']
				#print(fail_trig_unparsed)
				fail_trig_pairs = fail_trig_unparsed.split(';')
				for number_of_failures in range(len(fail_trig_pairs)):
					failure_trigger = re.findall('(.*?\(.*?\)),(.*?\(.*?\))',fail_trig_pairs[number_of_failures].strip())
					(trigger, failure) = failure_trigger[0]
					failure = failure.strip()
					trigger = trigger.strip()
					if trigger in failures:
						failures[trigger] += ";" + failure
					else:
						failures[trigger] = failure

				output("\nFailure for replica", index, ":\n", failures, sep = " ")

			if index == len(replica_list) - 1:
				isTail = True
			if index == 0:
				isHead = True
				timeout = self.head_timeout
			if index < len(replica_list) - 1:
				next_replica = replica_list[index + 1]
			if index > 0:
				prev_replica = replica_list[index - 1]
		
			timeout = int(timeout / 1000)

			setup(replica, (index, isHead, isTail, prev_replica, next_replica, replica_list[0], 
				[], 'ACTIVE', self.signing_key_list[index], self.verify_key_list, self.client_verify_key_list, 
				timeout, failures))

		
	def receive(msg =('check_configuration', message_id, _), from_= client):
		# send response to liveness check from client
		send(('check_configuration_response', 'OK', message_id, self), to = client)
		
	def receive(msg =('get_configuration', _), from_= client):
		# send current configuration (replica chain and their verify keys) to client
		configuration_response_msg = 'configuration_id:' + str(self.configuration_id)
		signed_msg = self.olympus_signing_key.sign(configuration_response_msg.encode())
		send(('get_configuration_response', self.configuration_id, self.replica_list, 
			self.verify_key_list, signed_msg, self), to = client)

	def run():
		test_name = config['test_case_name']
		output("\nStarting test case:", test_name, sep = " ")
		output("\nStarting Olympus.")
		# start replicas
		start(self.replicas)
		# send terminate messages to each replica when receive terminate messages from all clients
		if await(len(setof(c, received(('terminate', c, _)))) == self.client_num):
			for replica in self.replicas:
				send(('terminate', self), to = replica)
	#		if await(some(received(('final_dictionary', operation_dictionary), from_ = _))):
	##			send(('final_dictionary', operation_dictionary), to =c) 
