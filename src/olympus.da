import random
import nacl.encoding
import nacl.signing
import re

class Olympus(process):
	def setup(config, client_verify_key_list, olympus_signing_key):
		self.replica_num = int(config['t'])
		self.replica_num = replica_num * 2 + 1
		self.head_timeout = int(config['head_timeout'])
		self.nonhead_timeout = int(config['nonhead_timeout'])
		self.client_num = int(config['num_client'])
		self.configuration_id = 0
		self.quorum_size = int(config['t']) + 1		
		# create replicas
		replica_da = import_da('replica')
		self.replicas = new(replica_da.Replica, num = self.replica_num)
		self.replica_list = []
		self.signing_key_list = []
		self.verify_key_list = []	
		# put replicas to a list, and create signing key and verify key for each replica
		for replica in self.replicas:
			self.replica_list.append(replica)	
			replica_signing_key = nacl.signing.SigningKey.generate()
			replica_verify_key = replica_signing_key.verify_key
			replica_verify_key_hex = replica_verify_key.encode(encoder = nacl.encoding.HexEncoder)
			self.verify_key_list.append(replica_verify_key_hex)
			self.signing_key_list.append(replica_signing_key)
		
		# setup each replica
		for index in range(len(replica_list)):
			replica = replica_list[index]
			isHead = False
			isTail = False
			prev_replica = None
			next_replica = None
			timeout = self.nonhead_timeout

			failures = dict()
			if 'failures[' + str(self.configuration_id) + ',' + str(index) + ']' in config:
				fail_trig_unparsed = config['failures[' + str(self.configuration_id) + ',' + str(index) + ']']
				#print(fail_trig_unparsed)
				fail_trig_pairs = fail_trig_unparsed.split(';')
				for number_of_failures in range(len(fail_trig_pairs)):
					failure_trigger = re.findall('(.*?\(.*?\)),(.*?\(.*?\))',fail_trig_pairs[number_of_failures].strip())
					(trigger, failure) = failure_trigger[0]
					failure = failure.strip()
					trigger = trigger.strip()
					if trigger in failures:
						failures[trigger] += ";" + failure
					else:
						failures[trigger] = failure

				output("\nFailure for replica", index, ":\n", failures, sep = " ")

			if index == len(replica_list) - 1:
				isTail = True
			if index == 0:
				isHead = True
				timeout = self.head_timeout
			if index < len(replica_list) - 1:
				next_replica = replica_list[index + 1]
			if index > 0:
				prev_replica = replica_list[index - 1]
		
			timeout = int(timeout / 1000)

			setup(replica, (index, isHead, isTail, prev_replica, next_replica, replica_list[0], 
				[], 'ACTIVE', self.signing_key_list[index], self.verify_key_list, self.client_verify_key_list, 
				timeout, failures))

		
	def receive(msg =('check_configuration', message_id, _), from_= client):
		# send response to liveness check from client
		send(('check_configuration_response', 'OK', message_id, self), to = client)
		
	def receive(msg =('get_configuration', _), from_= client):
		# send current configuration (replica chain and their verify keys) to client
		configuration_response_msg = 'configuration_id:' + str(self.configuration_id)
		signed_msg = self.olympus_signing_key.sign(configuration_response_msg.encode())
		send(('get_configuration_response', self.configuration_id, self.replica_list, 
			self.verify_key_list, signed_msg, self), to = client)

	def receive(msg = ('reconfiguration_request', replica_id), from_= sending_replica):
		#assuming for now only replicas send reconfig request
		for replica in self.replicas:
			send(('wedge_request'), to = replica)
		#wait for replies from all replicas
		if await(len(setof(r, received(('wedge_statement', wedge_response, replica_id)))) == self.replica_num):
			successful_configuration_change = false
			while successful_configuration_change == false:
				#form a random quorum from the replica list
				quorum = random.sample(range(self.replica_num), self.quorum_size)	
				H = []
				for q in quorum:
					if received('wedge_statement', wedge_response, q):
						H.append((wedge_response, q))
				successful_configuration_change = switchConfig(H)
	
	def validHist(H):
		#H is a list of the form [(wedge,id), (wedge,id)...]
		#wedge is a signed wedge statement by every replica with replica_id = id. wedge = <"replica_id;history;dictionary;checkpointproof">_p 
		#history is of the form (slot, request_id, request, order_proof)

		wedged_statement_history_in_quorum = []
		for index in range(len(H)):
			#verify signature of each signed wedged statement in H
			try:
				verify_key = nacl.signing.VerifyKey(self.verify_key_list[index], encoder=nacl.encoding.HexEncoder)
				verify_key.verify(H[index][0])
			except nacl.exceptions.BadSignatureError:
                                #output("\nReplica", self.replica_id, ": checkpoint statement from proof is not validated, signature of replica", index, "doesn't match.", sep = " ")
				return None
			
			#current_wedge_statement contains the history part of each wedge
			current_wedge_statement = H[index][0].message.decode() 
			current_wedge_statement = current_wedge_statement.split(';')
			current_wedge_statement = current_wedge_statement[1]
			wedge_statement_history_in_quorum.append(current_wedge_statement)

		#check for any conflicting slot and operation in replicas that make the quorum
		for index in range(len(wedge_statement_history_in_quorum)-1):
			for (slot, request_id, request, order_proof) in wedge_statement_history_in_quorum[index]:
				if slot in [t[0] for t in wedge_statement_history_in_quorum[index+1]]:
					if request not in [t[2] for t in wedge_statement_history_in_quorum[index+1]]:
						return False
		
		#validate order proof in wedged statements:
		for i in range(len(H)):
			(wedge,replica_id) = H[i]
			for (slot, request_id, request, order_proof) in wedge_statement_history_in_quorum[i]:
				for index in range(replica_id):
					signed_order_stmt = order_proof[index]
					# verify the signature
					try:
						verify_key = nacl.signing.VerifyKey(self.verify_key_list[index], encoder=nacl.encoding.HexEncoder)
						verify_key.verify(signed_order_stmt)
					except nacl.exceptions.BadSignatureError:
						output("\nReplica", self.replica_id, ": order statement from shuttle is not validated, signature of replica",index, "doesn't match.", sep = " ")
						return False
					# get order statement by decoding message from signed message
					order_stmt = signed_order_stmt.message.decode()
					matches = re.findall("order<(\d+),\((\d+),\s+(\d+)\),(.*?)>", order_stmt)
					# there should only be one match
					if len(matches) != 1:
						output("\nReplica", self.replica_id, ": message in order statement from shuttle doesn't match.", sep = " ")
						return False
		return True
	
	def switchConfig(H):
		#precondition checks
		if self.quorum_size == len(H) and validHist(H):
			print("much work to be done!") 
			
		
	def run():
		test_name = config['test_case_name']
		output("\nStarting test case:", test_name, sep = " ")
		output("\nStarting Olympus.")
		# start replicas
		start(self.replicas)
		# send terminate messages to each replica when receive terminate messages from all clients
		if await(len(setof(c, received(('terminate', c, _)))) == self.client_num):
			for replica in self.replicas:
				send(('terminate', self), to = replica)
	#		if await(some(received(('final_dictionary', operation_dictionary), from_ = _))):
	##			send(('final_dictionary', operation_dictionary), to =c) 
