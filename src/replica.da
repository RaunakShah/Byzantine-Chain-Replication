import re
from nacl.bindings.utils import sodium_memcmp 
import nacl.encoding
import nacl.signing
import nacl.hash
import time
import logging
import os

class Replica(process):
	def setup(replica_id, running_state, isHead, isTail, prev_replica, next_replica, head, olympus, configuration_id, history,
			mode, signing_key, verify_key_list, client_verify_key_list, timeout, failures, checkpt_interval):
		# current slot number
		self.slot_num = 0
		# set running state
		if running_state is None:
			self.operation_dict = dict()
		else:
			self.operation_dict = running_state
		self.cache = dict()
		#self.count = 0
		self.HASHER = nacl.hash.sha256
		self.forward_request_received = dict()
		self.client_request_received = dict()
		# failure variables
		self.change_operation_failure = 0
		self.change_result_failure = 0
		self.drop_result_stmt_failure = 0
		self.invalid_order_sig_failure = 0
		self.received_checkpoint_count = 0
		self.completed_checkpoint_count = 0
		self.get_running_state_count = 0
		self.catch_up_count = 0
		self.wedge_request_count = 0
		self.new_configuration_count = 0
		self.truncate_history_failure = 0
		self.invalid_order_sig_failure = 0
		self.invalid_result_sig_failure = 0	
		self.drop_checkpt_stmts = 0
		self.drop = 0
		
		# checkpoint variables
		self.checkpoint_index = 0
		self.checkpoint_interval = checkpt_interval
		self.latest_checkpoint_proof = []
		self.last_checkpoint_slot = 0
		self.checkpoint_hash = None
		# majority number
		self.majority_num = (len(self.verify_key_list) - 1) / 2 + 1
		output("\nReplica:", replica_id, "with history", history, "initiated", sep = " ")
				
	#1. replica p receives operation request from replica client
	def receive(msg = ('operation_request', request_id, request_type, request, signed_msg, client), from_ = _):
		# verify client signature and validate request message
		try:
			client_key = nacl.signing.VerifyKey(self.client_verify_key_list[request_id[0]], encoder=nacl.encoding.HexEncoder)
			client_key.verify(signed_msg)
		except nacl.exceptions.BadSignatureError:
			output("\nReplica", self.replica_id, ": message from client is not validated, signature doesn't match.", sep = " ")
			return
		output("\nReplica", self.replica_id, ": message from client is validated", sep = " ")
			
		message = signed_msg.message
		if ("request<" + str(request_id) + "," + request + ">") != message.decode():
			output("\nReplica", self.replica_id, ": message from client is not validated, message doesn't match.", sep = " ")
			return
	
		output("\nReplica", self.replica_id, ": received", request_type, "operation request", 
			request_id, "for operation:", request, sep = " ") 
		
		if request_id[0] in self.client_request_received:
			self.client_request_received[request_id[0]] += 1
		else:
			self.client_request_received[request_id[0]] = 0

		if (request_type == 'new'):
			if(self.isHead == True):
				# check for client_request trigger
				if 'client_request(' + str(request_id[0]) + ',' + str(self.client_request_received[request_id[0]]) + ')' in self.failures:
					trigger = 'client_request(' + str(request_id[0]) + ',' + str(self.client_request_received[request_id[0]]) + ')'
					output("\nReplica", self.replica_id, ": failure", failures[trigger], "triggered by", trigger, sep = " ")
					failureInjection(failures[trigger], 1)

				if self.drop > 0:
					output("\n:Replica", self.replica_id, ": injecting failure drop() to incoming new operation_request", sep = " ")
					self.drop = 0
					return
					
				output("\nReplica", self.replica_id, ": handling new request from", client, sep = " ")
				handleNewRequest(request_id, request_type, request, client, signed_msg)
					
		elif (request_type == 'retransmission' or request_type == 'forward'):
			if 'client_request(' + str(request_id[0]) + ',' + str(self.client_request_received[request_id[0]]) + ')' in self.failures:
				trigger = 'client_request(' + str(request_id[0]) + ',' + str(self.client_request_received[request_id[0]]) + ')'
				output("\nReplica", self.replica_id, ": failure", failures[trigger], "triggered by", trigger, sep = " ")
				failureInjection(failures[trigger], 2)
			
			if self.drop > 0:
				output("\n:Replica", self.replica_id, ": injecting failure drop() to incoming retransmission operation_request", sep = " ")
				self.drop = 0
				return
			
			if (request_id in self.cache.keys() 
					and len(self.cache[request_id]) == 4):
				output("\nReplica", self.replica_id, ": retransmission request", request_id, "exist in cache.", sep = " ") 
				# check for forwarded_request trigger
				if self.isHead == True:
					if request_type == 'forward':
						if request_id[0] in self.forward_request_received:
							self.forward_request_received[request_id[0]] += 1
						else: 	
							self.forward_request_received[request_id[0]] = 0

						if 'forwarded_request(' + str(request_id[0]) + ',' + str(self.forward_request_received[request_id[0]]) + ')' in self.failures:
							trigger = 'forwarded_request(' + str(request_id[0]) + ',' + str(self.forward_request_received[request_id[0]]) + ')'
							output("\nReplica", self.replica_id, ": failure", failures[trigger], "triggered by", trigger, sep = " ")
							failureInjection(failures[trigger], 2)
				
				if self.drop > 0:
					output("\n:Replica", self.replica_id, ": injecting failure drop() to incoming retransmission operation_request", sep = " ")
					self.drop = 0
					return
					
				result_proof = self.cache[request_id][3]
					
				# check for failure change_result()
				if self.change_result_failure > 0:
					output("\nReplica", self.replica_id, ": injecting change_result failure for request", request_id, "at result", sep = " ")
					change_result_in_bytes = bytes('OK', 'utf-8')
					change_result_hash = self.HASHER(change_result_in_bytes, encoder = nacl.encoding.HexEncoder)
					result_stmt_msg = 'result<' + str(result_shuttle_id) + ',' + request + '>'
					signed_result = self.signing_key.sign(change_result_hash + result_stmt_msg.encode())
					result_proof[self.replica_id] = ((self.replica_id, signed_result))
					self.change_result_failure -= 1
				
				# check for failure drop_result_stmt()
				if self.drop_result_stmt_failure > 0:
					output("\nReplica", self.replica_id, ": injecting drop_result_stmt failure for request", result_shuttle_id, "at result", sep = " ")
					if (len(result_proof)) > 0:
						result_proof = result_proof[1:]
					self.drop_result_stmt_failure -= 1
			
				# send operation result directly back to client
				send(('operation_result', request_id, 'retransmission', cache[request_id][1], cache[request_id][0], result_proof, self), to = client)
				
				output("\nReplica", self.replica_id, ": sent result for retransmission request", request_id, "to client", client, sep = " ")
			elif self.mode == "IMMUTABLE":
				output("\nReplica", self.replica_id, ": received retransmission request in IMMUTABLE state, do nothing.", sep = " ")
				return	
			else:
				if (self.isHead == True):
					# check for forwarded_request trigger
					if (request_type == 'forward'):
						if request_id[0] in self.forward_request_received:
							self.forward_request_received[request_id[0]] += 1
						else: 	
							self.forward_request_received[request_id[0]] = 0
							
						if 'forwarded_request(' + str(request_id[0]) + ',' + str(self.forward_request_received[request_id[0]]) + ')' in self.failures:
							trigger = 'forwarded_request(' + str(request_id[0]) + ',' + str(self.forward_request_received[request_id[0]]) + ')'
							output("\nReplica", self.replica_id, ": failure", failures[trigger], "triggered by", trigger, sep = " ")
							failureInjection(failures[trigger], 2)
					
					if self.drop > 0:
						output("\n:Replica", self.replica_id, ": injecting failure drop() to incoming retransmission operation_request", sep = " ")
						self.drop = 0
						return
			
					if request_id in self.cache and self.cache[request_id][1] == request: 
						# head has ordered operation but not received result shuttle yet
						output("\nReplica", self.replica_id, ": retransmission request", request_id, "is performed but has not received result shuttle.", sep = " ") 
						# handle retransmission
						handleRetransmit(request_id, request, client)
						return
					else: 
						output("\nReplica", self.replica_id, ": retransmission request", request_id, "for operation", request, "is not recognized, start new operation.", sep = " ") 
						# head doesnt recognize operation, start new operation process
						handleNewRequest(request_id, request_type, request,	client, signed_msg)
						# handle retransmission
						handleRetransmit(request_id, request, client)
						return

				else: # replica that receives retransmission is not head
					output("\nReplica", self.replica_id, ": nonhead replica receives retransmission request", request_id, "forward request to head.", sep = " ") 
					send(('operation_request', request_id, 'forward', request, signed_msg, client), to = self.head)

					# handle retransmission
					handleRetransmit(request_id, request, client)
					return

	def handleRetransmit(request_id, request, client):
		if (await(
				some(received(('result_shuttle', result_shuttle_id, result_request, result, result_proof, _), 
					from_ = self.next_replica), 
				has = (result_shuttle_id == request_id and result_request == request)))):
			# check for failure change_result()
			if self.change_result_failure > 0:
				output("\nReplica", self.replica_id, ": injecting change_result failure for request", request_id, "at result", sep = " ")
				change_result_in_bytes = bytes('OK', 'utf-8')
				change_result_hash = self.HASHER(change_result_in_bytes, encoder = nacl.encoding.HexEncoder)
				result_stmt_msg = 'result<' + str(result_shuttle_id) + ',' + request + '>'
				signed_result = self.signing_key.sign(change_result_hash + result_stmt_msg.encode())
				result_proof[self.replica_id] = (self.replica_id, signed_result)
				self.change_result_failure -= 1
			
			# check for failure drop_result_stmt()
			if self.drop_result_stmt_failure > 0:
				output("\nReplica", self.replica_id, ": injecting drop_result_stmt failure for request", result_shuttle_id, "at result", sep = " ")
				if (len(result_proof)) > 0:
					result_proof = result_proof[1:]
				self.drop_result_stmt_failure -= 1	
			
			output("\nReplica", self.replica_id, ": retransmssion request", request_id, "received result shuttle, send to client", client, sep = " ") 
			# receive result shuttle, send to client
			send(('operation_result', request_id, result_request, 'retransmission', result, result_proof, self), to = client)
		elif (some(received(('wedge_request', _), from_ = _))):
			# receive wedged request, do nothing
			return
		elif timeout(self.timeout):
			# handle timeout, send reconfiguration request to Olympus
			output("\nReplica", self.replica_id, ": timeout handling retransmission request", request_id, 
				"send reconfiguration request to Olympus.", sep = " ")
			send(('reconfiguration_request', self.replica_id, self.configuration_id, self), to = self.olympus)
			
	
	def handleNewRequest(request_id, request_type, request, client, signed_msg):
		# we don't use this method because it's hard to inject failure increment_slot()
		# find the max slot that has been assigned to get the slot to assign
		#max_slot = 0
		#for (s, _, _, _) in self.history:
		#	if(s >= max_slot):
		#		max_slot = s
		#if len(self.history) == 0:
		#	slot = 0
		#else:
		#	slot = max_slot + 1
		
		slot = self.slot_num
		
		# create empty lists for order proof and result proof
		order_proof = []
		result_proof = []
		
		# get result and signed order statement of the request
		tuple = applyOperation(slot, request_id, request, order_proof)
		if tuple:
			output("\nReplica", self.replica_id, ": obtained result and signed order statement for request", request_id, sep = " ")
			(result, signed_order_stmt) = tuple
		else:
			return
					
		# check if inject failure change_result()
		if self.change_result_failure > 0:
			output("\nReplica", self.replica_id, ": injecting change_result failure for request", request_id, sep = " ")
			result = 'OK'
			self.change_result_failure -= 1
		
		# check for failure change_operation()
		if self.change_operation_failure > 0:
			output("\nReplica", self.replica_id, ": injecting change_operation failure for request", request_id, "at shuttle.", sep = " ")
			op_request = "get('x')"
			self.change_operation_failure -= 1
			
			# make order statement a string so it can be turned into bytes and signed 
			order_statement = "order<" + str(slot) + "," + str(request_id) + "," + op_request + ">"
			# sign order statement using the signing key of this replica
			signed_order_stmt = self.signing_key.sign(order_statement.encode())
			output("\nReplica", self.replica_id, ": hashed and signed order statement for request", request_id, "at shuttle.", sep = " ")
		else:
			op_request = request
			
		# hash and sign the result along with request id and request
		result_in_bytes = bytes(result, 'utf-8')
		hash_result = self.HASHER(result_in_bytes, encoder = nacl.encoding.HexEncoder)
		result_stmt_msg = 'result<' + str(request_id) + ',' + op_request + '>'
		signed_result = self.signing_key.sign(hash_result + result_stmt_msg.encode())
		output("\nReplica", self.replica_id, ": hashed and signed result statement for request", request_id, "at shuttle.", sep = " ")

		# add signed order statement and result statement to order proof and result proof
		order_proof.append(signed_order_stmt)
		result_proof.append((self.replica_id, signed_result))
		
		if self.isTail != True:
			# send shuttle to next replica
			send(('shuttle', order_proof, result_proof, request_id, request_type, slot, request, signed_msg, client, self), to = self.next_replica)
			output("\nReplica", self.replica_id, ": sent shuttle", request_id, "to ", self.next_replica, sep = " ")
		else:
			# if there is only 1 replica in the chain, send result to client directly
			send(('operation_result', request_id, request, request_type, result, result_proof, self), to = client)
			output("\nReplica", self.replica_id, ": sent operation_result", request_id[1], "to client", request_id[0], sep = " ")
	
	def applyOperation(slot, request_id, request, order_proof):
		"""
		Perform condition checks then run the request
		"""
		# this replica must be in ACTIVE mode
		if(self.mode != 'ACTIVE'):
			output("\nReplica", self.replica_id, ": mode is not 'ACTIVE'.", sep = " ")
			# this is a proof of misbehavior if replica is not in state 'IMMUTABLE', send reconfig request immediately
			if (self.mode != 'IMMUTABLE'):
				output("\nReplica", self.replica_id, ": find proof of misbehavior handling request", request_id, 
					"send reconfiguration request to Olympus.", sep = " ")
				send(('reconfiguration_request', self.replica_id, self.configuration_id, self), to = self.olympus)
			return None

		# check if there is any conflict in current request and history of this replica
		# the slot number shouldn't have been assigned to any other request
		if slot in [t[0] for t in self.history]:
			output("\nReplica", self.replica_id, ": conflict in current request and history for slot number", slot, sep = " ")
			# this is a proof of misbehavior, send reconfig request immediately
			output("\nReplica", self.replica_id, ": find proof of misbehavior handling request", request_id, 
				"send reconfiguration request to Olympus.", sep = " ")
			send(('reconfiguration_request', self.replica_id, self.configuration_id, self), to = self.olympus)
			return None
	
		#check for hole
		for checking_slot in range(self.last_checkpoint_slot, slot):
			if checking_slot not in [t[0] for t in self.history]:
				output("\nReplica", self.replica_id, ": there is a hole in the history for slot number", checking_slot, sep = " ")
				# this is a proof of misbehavior, send reconfig request immediately
				output("\nReplica", self.replica_id, ": find proof of misbehavior handling request", request_id, 
					"send reconfiguration request to Olympus.", sep = " ")
				send(('reconfiguration_request', self.replica_id, self.configuration_id, self), to = self.olympus)
				return None
		
		#checkpointing 
		#Increase checkpoint index and test equality with checkpoint interval
		if self.isHead:
			self.checkpoint_index += 1 
			if self.checkpoint_index == self.checkpoint_interval:
				output("\nReplica", self.replica_id, ": head reaches checkpoint index", self.checkpoint_interval, "initiate checkpoint proof", 
					"at slot", slot, sep = " ")
				checkpoint_prefix = self.checkpoint_interval
				checkpoint_proof_statement_list = []
				
				# get hash of current state and save it for future comparison
				state_in_bytes = bytes(str(self.operation_dict), 'utf-8')
				state_hash = self.HASHER(state_in_bytes, encoder = nacl.encoding.HexEncoder)
				self.checkpoint_hash = state_hash
				output("\nReplica", self.replica_id, ": hashed current state and saved for future comparison", sep = " ")
				
				# sign hash of current state and append it to checkpoint proof
				signed_checkpoint_statement = self.signing_key.sign(state_hash)
				checkpoint_proof_statement_list.append((self.replica_id, signed_checkpoint_statement))
				output("\nReplica", self.replica_id, ": signed current state and appended to checkpoint proof", sep = " ")
				
				#send checkpoint proof to next replica in chain
				output("\nReplica", self.replica_id, ": sent checkpoint proof for index", self.checkpoint_index, "to", self.next_replica, sep = " ")
				send(('checkpoint_proof', checkpoint_proof_statement_list, checkpoint_prefix, slot, self), to = self.next_replica) 
				
				# set checkpoint index back to 0
				self.checkpoint_index = 0
				output("\nReplica", self.replica_id, ": set checkpoint index to 0", sep = " ")
			
		# validate order proof from shuttle
		# check if all replicas preceding this replica have signed order statement and have correct slot and request id
		for index in range(self.replica_id):
			signed_order_stmt = order_proof[index]
			# verify the signature
			try:
				verify_key = nacl.signing.VerifyKey(self.verify_key_list[index], encoder=nacl.encoding.HexEncoder)
				verify_key.verify(signed_order_stmt)
			except nacl.exceptions.BadSignatureError:
				output("\nReplica", self.replica_id, ": order statement from shuttle is not validated, signature of replica", 
					index, "doesn't match.", sep = " ")
				return None
				
			output("\nReplica", self.replica_id, ": message from replica is validated", sep = " ")
			# get order statement by decoding message from signed message
			order_stmt = signed_order_stmt.message.decode()
			matches = re.findall("order<(\d+),\((\d+),\s+(\d+)\),(.*?)>", order_stmt)
			# there should only be one match
			if len(matches) != 1:
				output("\nReplica", self.replica_id, ": message in order statement from shuttle doesn't match.", sep = " ")
				return None
			output("\nReplica", self.replica_id, ": received and successfully decoded signed order statement", sep = " ")
			# check if there is any conflict in slot number and request id 
			(slot_str, client_id_str, workload_id_str, request_str) = matches[0]
			if (slot != int(slot_str) 
					or request_id[0] != int(client_id_str) 
					or request_id[1] != int(workload_id_str)
					or request != request_str):
				output("\nReplica", self.replica_id, ": message in order statement from shuttle doesn't match.", sep = " ")
				return None
			output("\nReplica", self.replica_id, ": no conflict in slot number and request id during order proof validation", sep = " ")

		# apply operation in the request to the dictionary object
		result = findAndPerformOperation(request)
		
		if result == None:
			output("\nReplica", self.replica_id, ": perform operation fail, no result returned.", sep = " ")
			return None
		
		output("\nReplica", self.replica_id, ": applied operation and result returned.", sep = " ")

		# get order statement of current replica
		current_signed_order_stmt = orderCommand(slot, request_id, request, order_proof)
	
		# hash and sign the result along with request id and request
		result_in_bytes = bytes(result, 'utf-8')
		hash_result = self.HASHER(result_in_bytes, encoder = nacl.encoding.HexEncoder)
		result_stmt_msg = 'result<' + str(request_id) + ',' + request + '>'
		signed_result = self.signing_key.sign(hash_result + result_stmt_msg.encode())
		output("\nReplica", self.replica_id, ": hashed and signed result",  sep = " ")
		
		# cache result, request, and result statement
		self.cache[request_id] =  (result, request, signed_result)
		
		return (result, current_signed_order_stmt)
		
	def findAndPerformOperation(request):
		"""
		Perform the operation in the request
		"""
		
		request = request.strip()
		if request.startswith('put'):
			# put operation
			operands = re.findall("put\(\'(.*?)\'\,\s*\'(.*?)\'\)", request, re.DOTALL)
			# there should only be one tuple of operands found
			if len(operands) != 1:
				return None
				
			(key, val) = operands[0]
			self.operation_dict[key] = val
			return 'OK'
		elif request.startswith('get'):
			# get operation
			operand = re.findall('get\(\'(.*?)\'\)', request)
			# there should only be one operand found
			if len(operand) != 1:
				return None

			o = operand[0]
			if o in self.operation_dict:
				return self.operation_dict.get(o)
			else:
				return ""
	
		elif request.startswith('append'):
			# append operation
			operands = re.findall('append\(\'(.*?)\'\,\s*\'(.*?)\'\)', request, re.DOTALL)
			# there should only be one tuple of operands found
			if len(operands) != 1:
				return None
			
			(key, val) = operands[0]
			if key in self.operation_dict:
				self.operation_dict[key] += val
				return 'OK'
			else:
				return 'fail'
		elif request.startswith('slice'):
			# slice operation
			operands = re.findall('slice\(\'(.*?)\',\s*\'(\d+):(\d+)\'\)', request)
			# there should only be one tuple of operands found
			if len(operands) != 1:
				return None
				
			(key, low_index, up_index) = operands[0]
			if (key in self.operation_dict 
					and int(low_index) in range(len(self.operation_dict[key])) 
					and int(up_index) in range(len(self.operation_dict[key]))):
				self.operation_dict[key] = self.operation_dict[key][(int)(low_index):(int)(up_index)]
				return 'OK'
			else:
				return 'fail'
		else:
			return None

	def orderCommand(slot, request_id, request, order_proof):
		"""
		Create a signed order statement and create an order proof to append to history of this replica
		"""
		
		# create an order statement for this replica
		# make order statement a string so it can be turned into bytes and signed 
		order_statement = "order<" + str(slot) + "," + str(request_id) + "," + request + ">"
		# sign order statement using the signing key of this replica
		signed_order_stmt = self.signing_key.sign(order_statement.encode())
		
		# add order statement from previous replicas to order proof
		current_order_proof = order_proof[:self.replica_id]
		current_order_proof.append(signed_order_stmt)
		
		# add the signed order statement to history
		self.history.append((slot, request_id, request, current_order_proof))
		output("\nReplica", self.replica_id, ": signed order statement and added order proof to history",  sep = " ")
		
		# increment slot number
		self.slot_num += 1
		
		# check for failure invalid_order_sig()
		if self.invalid_order_sig_failure > 0:
			output("\nReplica", self.replica_id, ": injecting invalid_order_sig failure for request", request_id, "at shuttle.", sep = " ")
			
			# increment the first byte of the signature in a nacl.signing.SignedMessage
			signedlist = list(signed_order_stmt)
			signedlist[0] = (signedlist[0] + 1) % 256
			newsigned = bytes(signedlist)
			invalid_signed = nacl.signing.SignedMessage._from_parts(signed_order_stmt._signature, signed_order_stmt._message, newsigned)
			signed_order_stmt = invalid_signed
			
			self.invalid_order_sig_failure -= 1
			
		return signed_order_stmt
    
	#2. replica receives shuttle
	def receive(msg =('shuttle', order_proof, result_proof, request_id, request_type, slot, request, signed_msg, client, _), from_= self.prev_replica):
		# verify client signature and validate request message from shuttle
		try:
			client_key = nacl.signing.VerifyKey(self.client_verify_key_list[request_id[0]], encoder=nacl.encoding.HexEncoder)
			client_key.verify(signed_msg)
		except nacl.exceptions.BadSignatureError:
			output("\nReplica", self.replica_id, ": in shuttle from", self.prev_replica, "message from client is not validated, signature doesn't match.", sep = " ")
			return
		
		output("\nReplica", self.replica_id, ": shuttle message from replica is validated", sep = " ")

		message = signed_msg.message
		if ("request<" + str(request_id) + "," + request + ">") != message.decode():
			output("\nReplica", self.replica_id, ": in shuttle from", self.prev_replica, "message from client is not validated, message doesn't match.", sep = " ")
			return
		
		output("\nReplica", self.replica_id, ": received shuttle", request_id, "from", self.prev_replica, sep = " ")
		
		# check for failure trigger shuttle()
		if 'shuttle(' + str(request_id[0]) + ',' + str(request_id[1]) + ')' in self.failures:
			trigger = 'shuttle(' + str(request_id[0]) + ',' + str(request_id[1]) + ')'
			output("\nReplica", self.replica_id, ": failure", failures[trigger], "triggered by", trigger, sep = " ")
			failureInjection(failures[trigger], 1)
		
		if self.drop > 0:
			output("\n:Replica", self.replica_id, ": injecting failure drop() in shuttle", sep = " ")
			self.drop = 0
			return
			
		# apply operation and get result and signed order statement
		tuple = applyOperation(slot, request_id, request, order_proof)
		if tuple:
			(result, signed_order_stmt) = tuple
		else:
			return
		
		hash_result = result
		
		# check if inject failure change_result()
		if self.change_result_failure > 0:
			output("\nReplica", self.replica_id, ": injecting change_result failure for request", request_id, "at shuttle.", sep = " ")
			hash_result = 'OK'
			self.change_result_failure -= 1
		
		# check for failure change_operation()
		if self.change_operation_failure > 0:
			output("\nReplica", self.replica_id, ": injecting change_operation failure for request", request_id, "at shuttle.", sep = " ")
			op_request = "get('x')"
			self.change_operation_failure -= 1
		
			# make order statement a string so it can be turned into bytes and signed 
			order_statement = "order<" + str(slot) + "," + str(request_id) + "," + op_request + ">"
			# sign order statement using the signing key of this replica
			#invalid signature failure
			if self.invalid_order_sig_failure > 0:
				invalid_signing_key = nacl.signing.SigningKey.generate()
				signed_order_stmt = invalid_signing_key.sign(order_statement.encode())
				self.invalid_order_sig_failure = 0
				output("\nReplica", self.replica_id, ": injecting invalid_order_sig failure for request", request_id, "at shuttle.", sep = " ")
			else:		
				signed_order_stmt = self.signing_key.sign(order_statement.encode())
				output("\nReplica", self.replica_id, ": signed order statement for request", request_id, "at shuttle.", sep = " ")
		else:
			op_request = request

		# hash and sign the result along with request id and request
		result_in_bytes = bytes(hash_result, 'utf-8')
		result_hash = self.HASHER(result_in_bytes, encoder = nacl.encoding.HexEncoder)
		result_stmt_msg = 'result<' + str(request_id) + ',' + op_request + '>'
		signed_result = self.signing_key.sign(result_hash + result_stmt_msg.encode())
		output("\nReplica", self.replica_id, ": hashed and result for request", request_id, "at shuttle.", sep = " ")
		
		# add signed order statement and result statement to order proof and result proof
		order_proof.append(signed_order_stmt)
		result_proof.append((self.replica_id, signed_result))
		
		# check if inject failure drop_result_stmt()
		if self.drop_result_stmt_failure > 0:
			output("\nReplica", self.replica_id, ": injecting drop_result_stmt failure for request", request_id, "at shuttle.", sep = " ")
			if len(result_proof) > 0:
				result_proof = result_proof[1:]
			self.drop_result_stmt_failure -= 1
			
		if self.isTail == True:
			# cache result proof
			# it's ok not to validate here, since if result shuttle is faulty, not majority of replica will cache result proof
			result_stmt_in_cache = self.cache[request_id][2]
			self.cache[request_id] = (result, request, result_stmt_in_cache, result_proof)
			
			output("\nReplica", self.replica_id, ": sent result_shuttle", request_id, "to replica", self.prev_replica, sep = " ")
			send(('result_shuttle', request_id, request, result, result_proof, self), to = self.prev_replica)
			if self.invalid_result_sig_failure > 0:
				output("\nReplica", self.replica_id, ": injecting invalid_result_sig failure for request", request_id, "at shuttle.", sep = " ")
				result_proof = result_proof[:-1]
				invalid_signing_key = nacl.signing.SigningKey.generate()
				signed_result = invalid_signing_key.sign(result_hash + result_stmt_msg.encode())
				result_proof.append((self.replica_id, signed_result))
				self.invalid_result_sig_failure = 0
			output("\nReplica", self.replica_id, ": sent operation_result", request_id, "to client", client, sep = " ")
			send(('operation_result', request_id, request_type, request, result, result_proof, self), to = client)
		else:
			if self.invalid_result_sig_failure > 0:
				output("\nReplica", self.replica_id, ": injecting invalid_result_sig failure for request", request_id, "at shuttle.", sep = " ")
				result_proof = result_proof[:-1]
				invalid_signing_key = nacl.signing.SigningKey.generate()
				signed_result = invalid_signing_key.sign(result_hash + result_stmt_msg.encode())
				result_proof.append(signed_result)
				self.invalid_result_sig_failure = 0
			
			output("\nReplica", self.replica_id, ": sent shuttle", request_id, "to", self.next_replica, sep = " ")
			send(('shuttle', order_proof, result_proof, request_id, request_type, slot, request, signed_msg, client, self), to = self.next_replica)

	#3. replica p receives result shuttle
	def receive(msg =('result_shuttle', result_shuttle_id, request, result, result_proof, _), from_ = self.next_replica):
		output("\nReplica", self.replica_id, ": received result_shuttle", result_shuttle_id, "from", self.next_replica, sep = " ")

		# check for failure trigger result_shuttle()
		if 'result_shuttle(' + str(result_shuttle_id[0]) + ',' + str(result_shuttle_id[1]) + ')' in self.failures:
			trigger = 'result_shuttle(' + str(result_shuttle_id[0]) + ',' + str(result_shuttle_id[1]) + ')'
			output("\nReplica", self.replica_id, ": failure", failures[trigger], "triggered by", trigger, sep = " ")
			failureInjection(failures[trigger], 1)

		if self.drop > 0:
			output("\n:Replica", self.replica_id, ": injecting failure drop() in result_shuttle", sep = " ")
			self.drop = 0
			return
			
		# validate result shuttle
		# check if result shuttle contains result statement from all replicas
		if (len(result_proof) != len(self.verify_key_list)):
			output("\nReplica", self.replica_id, ": result shuttle for", result_shuttle_id, "does not contain enough entries, expected", 
				len(self.verify_key_list), "but only receive", len(result_proof), "ignore this result shuttle", sep = " ")
			return
		
		output("\nReplica", self.replica_id, ": result shuttle for", result_shuttle_id, "contains enough entries, expected", 
			len(self.verify_key_list), "and received", len(result_proof),sep = " ")	

		# check if all replicas preceding this replica have signed result statement
		for index in range(self.replica_id):
			signed_result_stmt = [t[1] for t in result_proof if t[0] == index][0]
			
			# verify the signature
			try:
				verify_key = nacl.signing.VerifyKey(self.verify_key_list[index], encoder=nacl.encoding.HexEncoder)
				verify_key.verify(signed_result_stmt)
			except nacl.exceptions.BadSignatureError:
				output("\nReplica", self.replica_id, 
					": message received from result shuttle is not validated, signature doesn't match.", sep = " ")
			output("\nReplica", self.replica_id, ": result shuttle from replica is validated", sep = " ")
			
			# validate sign message
			result_message = signed_result_stmt.message
			result_stmt_hash = result_message[:64]
			message = result_message[64:]
			if ('result<' + str(result_shuttle_id) + ',' + request + '>') != message.decode():
				output("\nReplica", self.replica_id, 
					": message received from result shuttle is not validated, message doesn't match.", sep = " ")
				return
		
			# check if hash match with the replica's result
			result_in_bytes = bytes(self.cache[result_shuttle_id][0], 'utf-8')
			result_hash = self.HASHER(result_in_bytes, encoder = nacl.encoding.HexEncoder)
			if not sodium_memcmp(result_hash, result_stmt_hash):
				# hash does not match
				output("\nReplica", self.replica_id, ": hash of result for request", result_shuttle_id, "for operation", request,			
					"does not match hash of replica", index, "in result statement, ignore result shuttle.", sep = " ")
				return

		# check if current replica has processed the request id from result shuttle
		if result_shuttle_id not in self.cache:
			output("\nReplica", self.replica_id, ": request", result_shuttle_id, "does not exist in cache.", sep = " ")
			return

		# check if the request matches for the request id
		if self.cache[result_shuttle_id][1] != request:
			output("\nReplica", self.replica_id, ": request", result_shuttle_id, "for operation", request,			
				"does not match existing operation", self.cache[result_shuttle_id], "in cache.", sep = " ")
			return

		# cache result proof along with corresponding request id, result, and result statement
		result_stmt_in_cache = self.cache[result_shuttle_id][2]
		self.cache[result_shuttle_id] = (result, request, result_stmt_in_cache, result_proof)
		output("\nReplica", self.replica_id, ": cached result proof for request id", result_shuttle_id, sep = " ")
		
		# check for failure change_result()
		if self.change_result_failure > 0:
			output("\nReplica", self.replica_id, ": injecting change_result failure for request", result_shuttle_id, "at result shuttle", sep = " ")
			change_result_in_bytes = bytes('OK', 'utf-8')
			change_result_hash = self.HASHER(change_result_in_bytes, encoder = nacl.encoding.HexEncoder)
			result_stmt_msg = 'result<' + str(result_shuttle_id) + ',' + request + '>'
			signed_result = self.signing_key.sign(change_result_hash + result_stmt_msg.encode())
			result_proof[self.replica_id] = (self.replica_id, signed_result)
			self.change_result_failure -= 1
		
		# check for failure drop_result_stmt()
		if self.drop_result_stmt_failure > 0:
			output("\nReplica", self.replica_id, ": injecting drop_result_stmt failure for request", result_shuttle_id, "at result shuttle", sep = " ")
			if (len(result_proof)) > 0:
				result_proof = result_proof[1:]
			self.drop_result_stmt_failure -= 1
			
		# send result shuttle to previous replica
		if self.isHead == False:
			output("\nReplica", self.replica_id, ": sent result_shuttle", result_shuttle_id, "to", self.prev_replica, sep = " ")
			send(('result_shuttle', result_shuttle_id, request, result, result_proof, self), to= self.prev_replica)
			
	#4. replica receives wedge request
	def receive(msg = ('wedge_request', _), from_= self.olympus):
		output("\nReplica", self.replica_id, ": received wedge request from Olympus, become IMMUTABLE.", sep = " ")
		self.mode = 'IMMUTABLE'

		# check for wedge_request trigger
		self.wedge_request_count += 1
		if 'wedge_request(' + str(self.wedge_request_count) + ')' in self.failures:
			trigger = 'wedge_request(' + str(self.wedge_request_count) + ')'
			output("\nReplica", self.replica_id, ": failure", failures[trigger], "triggered by", trigger, sep = " ")
			failureInjection(failures[trigger], 1)

		if self.drop > 0:
			output("\n:Replica", self.replica_id, ": injecting failure drop() in wedge_request", sep = " ")
			self.drop = 0
			return
			
		if self.truncate_history_failure > 0:
			output("\nReplica", self.replica_id, ": injecting truncate_history failure for request", request_id, "at shuttle.", sep = " ")
			wedge_history = self.history[0:(len(self.history)-self.truncate_history_failure)]
			self.truncate_history_failure = 0
		else:
			wedge_history = self.history
		
		#sign and send (self.replica_id;self.history;self.operation_dict;self.latest_checkpoint_proof) in wedge statement
		wedged_msg = self.signing_key.sign((str(self.replica_id) + ';' + str(wedge_history) + ';' + str(self.latest_checkpoint_proof) + ';' + str(self.last_checkpoint_slot)).encode())
		output("\nReplica", self.replica_id, ": sent wedge statement to Olympus.", sep = " ")		
		send(('wedge_statement', wedged_msg, self.replica_id, wedge_history, self.latest_checkpoint_proof, self.last_checkpoint_slot, 
			self.configuration_id, self), to = self.olympus)

	#5. replica receives checkpoint proof shuttle (from head to tail)
	def receive(msg = ('checkpoint_proof', checkpoint_proof_statement_list, checkpoint_prefix, current_slot, _), from_ = self.prev_replica):
		output("\nReplica", self.replica_id, ": received checkpoint_proof shuttle for checkpoint interval", 
			checkpoint_prefix, "at slot", current_slot, "from", self.prev_replica, sep = " ")
		self.received_checkpoint_count += 1	
		if 'checkpoint(' + str(self.received_checkpoint_count) + ')' in self.failures:
					trigger = 'checkpoint(' + str(self.received_checkpoint_count) + ')'
					output("\nReplica", self.replica_id, ": failure", failures[trigger], "triggered by", trigger, sep = " ")
					failureInjection(failures[trigger], 1)
	
		if self.drop > 0:
			output("\n:Replica", self.replica_id, ": injecting failure drop() in checkpoint_proof", sep = " ")
			self.drop = 0
			return
			
		# wait until it has enough of statements in history first before adding to checkpoint proof
		if await(len(self.history) >= checkpoint_prefix):
			output("\nReplica", self.replica_id, ": reach", checkpoint_prefix, "statements in history, append to checkpoint proof shuttle",
				sep = " ")
		
			#generate checkpoint proof by hashing state and signing the message
			state_in_bytes = bytes(str(self.operation_dict), 'utf-8') 
			state_hash = self.HASHER(state_in_bytes, encoder = nacl.encoding.HexEncoder)
			self.checkpoint_hash = state_hash
			signed_checkpoint_statement = self.signing_key.sign(state_hash)
			checkpoint_proof_statement_list.append((self.replica_id, signed_checkpoint_statement))
		
			if self.isTail == False:
				#send checkpoint proof to next replica in chain
				output("\nReplica", self.replica_id, ": sent checkpoint proof for index", checkpoint_prefix, "to", self.next_replica, sep = " ")
				send(('checkpoint_proof', checkpoint_proof_statement_list, checkpoint_prefix, current_slot, self), to = self.next_replica) 
			else:
				if validateCheckpointProof(checkpoint_proof_statement_list, checkpoint_prefix):
					#delete history uptil checkpoint prefix
					self.last_checkpoint_slot += checkpoint_prefix
					self.history = self.history[checkpoint_prefix:]
					self.latest_checkpoint_proof = checkpoint_proof_statement_list
					output('\nReplica', self.replica_id, ': history before index', checkpoint_prefix, 'is removed, now start at slot number', 
						self.last_checkpoint_slot, sep = " " )
				
					output("\nReplica", self.replica_id, ": sent completed checkpoint result to", self.prev_replica, sep = " ")
					send(('checkpoint_result', checkpoint_proof_statement_list, checkpoint_prefix, current_slot, self), to = self.prev_replica)
			
	#6. replica receives completed checkpoint proof shuttle (from tail to head)
	def receive(msg = ('checkpoint_result', checkpoint_proof_statement_list, checkpoint_prefix, current_slot, _), from_ = self.next_replica):
		output("\nReplica", self.replica_id, ": received completed checkpoint_proof shuttle for checkpoint interval",
			checkpoint_prefix, "at slot", current_slot, "from", self.next_replica, sep = " ")
		
		self.completed_checkpoint_count += 1	
		if 'completed_checkpoint(' + str(self.completed_checkpoint_count) + ')' in self.failures:
					trigger = 'completed_checkpoint(' + str(self.completed_checkpoint_count) + ')'
					output("\nReplica", self.replica_id, ": failure", failures[trigger], "triggered by", trigger, sep = " ")
					failureInjection(failures[trigger], 1)
		
		if self.drop > 0:
			output("\n:Replica", self.replica_id, ": injecting failure drop() in checkpoint_result", sep = " ")
			self.drop = 0
			return
			
		#check if checkpoint proof contains entry for every replica
		if validateCheckpointProof(checkpoint_proof_statement_list, checkpoint_prefix):
			#delete history uptil checkpoint prefix
			self.last_checkpoint_slot += checkpoint_prefix
			self.history = self.history[checkpoint_prefix:]
			self.latest_checkpoint_proof = checkpoint_proof_statement_list
			output('\nReplica', self.replica_id, ': history before index', checkpoint_prefix, 'is removed, now start at slot number', 
				self.last_checkpoint_slot, sep = " " )
		
		if self.isHead == False:
			#handle failure drop checkpoint statements
			if self.drop_checkpt_stmts > 0:
				output("\nReplica", self.replica_id, ": injecting drop_checkpt_stmt failure for request", request_id, "at shuttle.", sep = " ")
				checkpoint_proof_statement_list = checkpoint_proof_statement_list[failures+1:]
				self.drop_checkpt_stmts = 0	
			send(('checkpoint_result', checkpoint_proof_statement_list, checkpoint_prefix, current_slot, self), to = self.prev_replica)
			output(self.replica_id, "sent completed checkpoint result to", self.prev_replica, sep = " ")

	
	def validateCheckpointProof(checkpoint_proof_statement_list, checkpoint_prefix):
		#check if checkpoint proof contains entry for majority of replica
		number_of_checkpoints = 0

		# check for each check point statement in checkpoint proof
		for index in range(len(checkpoint_proof_statement_list)):
			# get signed message
			(replica_index, signed_checkpoint_stmt) = checkpoint_proof_statement_list[index]
			
			# verify the signature
			try:
				verify_key = nacl.signing.VerifyKey(self.verify_key_list[replica_index], encoder=nacl.encoding.HexEncoder)
				verify_key.verify(signed_checkpoint_stmt)
			except nacl.exceptions.BadSignatureError:
				output("\nReplica", self.replica_id, ": checkpoint statement from proof is not validated, signature of replica", replica_index, 
					"doesn't match.", sep = " ")
				continue
			
			# get and validate checkpoint hash from message
			checkpoint_hash = signed_checkpoint_stmt.message
			
			# check if hashes match
			if not sodium_memcmp(checkpoint_hash, self.checkpoint_hash):
				# hash does not match
				output("\nReplica", self.replica_id, ": hash of state for index", checkpoint_prefix, 
					"does not match hash of state of replica", replica_index, 
					"in checkpoint statement.", sep = " ")
				continue
			
			number_of_checkpoints += 1
			
		if number_of_checkpoints < self.majority_num:
			output('\nReplica', self.replica_id, ': number of checkpoint proofs not enough, expected at least', self.majority_num, 
				'but only has', number_of_checkpoints, sep = " " )
			return False
			
		output('\nReplica', self.replica_id, ': checkpoint proof validated for index', checkpoint_prefix, 'with', number_of_checkpoints, 
			'validated checkpoint statements', sep = " " )
		return True
	
	def failureInjection(failure, num):
		""" handles all failure injections """
		if ';' in failure:
			failures = failure.split(';')
		else:
			failures = [failure]
		for f in failures:
			f.strip()
			if f == 'change_operation()':
				self.change_operation_failure = num
			elif f == 'change_result()':
				self.change_result_failure = num
			elif f == 'drop_result_stmt()':
				self.drop_result_stmt_failure = num
			elif f == 'crash()':
				output("\nReplica", self.replica_id, ": crach this replica.", sep = " ")
				logging.shutdown()
				os._exit(-1)
			elif f.startswith('truncate_history'):
				match = re.findall("truncate_history\((\d+)\)",f)
				n = int(match[0])
				self.truncate_history_failure = n
			elif f.startswith('sleep'):
				match = re.findall("sleep\((\d+)\)", f)
				# here assume no failures in parsing the sleep time
				sleep_time = int(match[0])
				sleep_time = sleep_time / 1000
				output("\nReplica", self.replica_id, ": slept for", sleep_time, "seconds", sep = " ")	
				time.sleep(sleep_time)
			elif f == 'drop()':
				self.drop = num
			elif f == 'increment_slot()':
				return
			elif f == 'extra_op()':
				output("\nReplica", self.replica_id, ": added extra put('a','a') to dictionary", sep = " ")	
				self.operation_dict['a'] = 'a'		
			elif f == 'invalid_order_sig()':
				self.invalid_order_sig_failure = num
			elif f == 'invalid_result_sig()':
				self.invalid_result_sig_failure = num
			elif f == 'drop_checkpt_stmts()':
				self.drop_checkpt_stmts = num
		
	def applyOperationDuringReconfiguration(slot, request_id, operation):
		output("\nReplica", self.replica_id, ": applying operation", operation, "at slot", slot, "during reconfiguration", sep = " ")
	
		# check if there is any conflict in current request and history of this replica
		# the slot number shouldn't have been assigned to any other request
		if slot in [t[0] for t in self.history]:
			output("\nReplica", self.replica_id, ": during reconfiguration, conflict in current request and history for slot number", slot, sep = " ")
			return None
	
		#check for hole
		for checking_slot in range(self.last_checkpoint_slot, slot):
			if checking_slot not in [t[0] for t in self.history]:
				output("\nReplica", self.replica_id, ": during reconfiguration, there is a hole in the history for slot number", checking_slot, sep = " ")
				return None

		# apply operation in the request to the dictionary object
		result = findAndPerformOperation(operation)
		
		if result == None:
			output("\nReplica", self.replica_id, ": during reconfiguration, perform operation fail, no result returned.", sep = " ")
			return None
			
		# hash and sign the result along with request id and operation
		result_in_bytes = bytes(result, 'utf-8')
		hash_result = self.HASHER(result_in_bytes, encoder = nacl.encoding.HexEncoder)
		result_stmt_msg = 'result<' + str(request_id) + ',' + operation + '>'
		signed_result = self.signing_key.sign(hash_result + result_stmt_msg.encode())
		
		# cache result, operation, and result statement
		self.cache[request_id] =  (result, operation, signed_result)
		
		return result
	
	#7. replica receives catch up message
	def receive(msg =("catch_up", catch_up_sequence, _), from_= self.olympus):
		output("\nReplica", self.replica_id, ": received catch_up request for sequence", catch_up_sequence, sep = " ")
		
		# check for caught_up trigger
		self.catch_up_count += 1	
		if 'catch_up(' + str(self.catch_up_count) + ')' in self.failures:
			trigger = 'catch_up(' + str(self.catch_up_count) + ')'
			output("\nReplica", self.replica_id, ": failure", failures[trigger], "triggered by", trigger, sep = " ")
			failureInjection(failures[trigger], 1)
		
		if self.drop > 0:
			output("\n:Replica", self.replica_id, ": injecting failure drop() in catch_up", sep = " ")
			self.drop = 0
			return
		
		for (slot, request_id, operation) in catch_up_sequence:
			res = applyOperationDuringReconfiguration(slot, request_id, operation)
			output("\nReplica", self.replica_id, ": during reconfiguration, perform operation succeeds, result is", res, sep = " ")
		
		# get hash of state
		state_in_bytes = (str(self.operation_dict)).encode() 
		state_hash = self.HASHER(state_in_bytes, encoder = nacl.encoding.HexEncoder)
		
		# get signed result stmt of all clients latest request
		result_stmt_dict = getLatestResultStmt()
		
		output("\nReplica", self.replica_id, ": send caught_up message and result state hash to Olympus", sep = " ")
		send(('caught_up', state_hash, self.replica_id, result_stmt_dict, self.configuration_id, self), to = self.olympus)
			
	def getLatestResultStmt():
		output("\nReplica", self.replica_id, ": start looking for latest result statement for each client.", sep = " ")
		# initialization
		latest_request_id_dict = dict()
		latest_result_stmt_dict = dict()
		# go through every item in cache, and find latest request id and signed result stmt
		for key in self.cache:
			# get client id
			client_id = key[0]
			if client_id not in latest_request_id_dict:
				latest_request_id_dict[client_id] = key
				latest_result_stmt_dict[client_id] = (key, self.cache[key][0], self.cache[key][1], (self.replica_id, self.cache[key][2]))
			
			# check if request id is larger
			latest_request_id = latest_request_id_dict[client_id]
			if (key[1] > latest_request_id[1]):
				# if it is larger, update latest request id and result stmt
				latest_request_id_dict[client_id] = key
				latest_result_stmt_dict[client_id] = (key, self.cache[key][0], self.cache[key][1], (self.replica_id, self.cache[key][2]))
			
		output("\nReplica", self.replica_id, ": find latest result for clients, the requests id of the results are", 
			latest_request_id_dict, sep = " ")
		return latest_result_stmt_dict
			
	
	#8. replica receives a get running state message
	def receive(msg = ("get_running_state", _), from_= self.olympus):
		output("\nReplica", self.replica_id, ": received get_running_state request.", sep = " ")
		
		# check for get_running_state trigger
		self.get_running_state_count += 1	
		if 'get_running_state(' + str(self.get_running_state_count) + ')' in self.failures:
			trigger = 'get_running_state(' + str(self.get_running_state_count) + ')'
			output("\nReplica", self.replica_id, ": failure", failures[trigger], "triggered by", trigger, sep = " ")
			failureInjection(failures[trigger], 1)
			
		if self.drop > 0:
			output("\n:Replica", self.replica_id, ": injecting failure drop() in get_running_state", sep = " ")
			self.drop = 0
			return
		
		output("\nReplica", self.replica_id, ": send running_state_message for current state to Olympus.", sep = " ")
		send(('running_state_message', self.operation_dict, self.replica_id, self.configuration_id, self), to = self.olympus)
			
	def run():
		output('\nStarting replica', self.replica_id, sep = " ")
		# terminate when receive terminate message from Olympus
		if await(some(received(('terminate', _), from_ = Olympus))):
			time.sleep(3)
			output('\nReplica', self.replica_id, 'state:', self.operation_dict,sep = " ")
			for a,b,c,d in self.history:
				output('\nReplica', self.replica_id, 'history: slot', a , '; request_id', b, '; request', c, sep = " ")
			output('\nReplica', self.replica_id, 'last checkpoint slot:', self.last_checkpoint_slot, sep = " ")
			#output('\nReplica', self.replica_id, 'latest checkpoint proof:', self.latest_checkpoint_proof, sep = " ")
