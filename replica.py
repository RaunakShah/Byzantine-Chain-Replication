# -*- generated by 1.0.9 -*-
import da
PatternExpr_280 = da.pat.TuplePattern([da.pat.ConstantPattern('operation_request'), da.pat.FreePattern('request_id'), da.pat.FreePattern('request_type'), da.pat.FreePattern('request'), da.pat.FreePattern(None)])
PatternExpr_292 = da.pat.FreePattern('client')
PatternExpr_511 = da.pat.TuplePattern([da.pat.ConstantPattern('shuttle'), da.pat.FreePattern('order_proof'), da.pat.FreePattern('result_proof'), da.pat.FreePattern('request_id'), da.pat.FreePattern('slot'), da.pat.FreePattern('request'), da.pat.FreePattern('client'), da.pat.FreePattern(None)])
PatternExpr_529 = da.pat.BoundPattern('_BoundPattern533_')
PatternExpr_765 = da.pat.TuplePattern([da.pat.ConstantPattern('operation_request'), da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)])
PatternExpr_773 = da.pat.FreePattern(None)
_config_object = {}
import re
import nacl.encoding
import nacl.signing

class Replica(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ReplicaReceivedEvent_2 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_0', PatternExpr_280, sources=[PatternExpr_292], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_279]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_1', PatternExpr_511, sources=[PatternExpr_529], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_510]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_2', PatternExpr_765, sources=[PatternExpr_773], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, replica_id, replica_list, history, mode, private_key, public_key_list, **rest_790):
        super().setup(replica_id=replica_id, replica_list=replica_list, history=history, mode=mode, private_key=private_key, public_key_list=public_key_list, **rest_790)
        self._state.replica_id = replica_id
        self._state.replica_list = replica_list
        self._state.history = history
        self._state.mode = mode
        self._state.private_key = private_key
        self._state.public_key_list = public_key_list
        self._state.isHead = False
        self._state.isTail = False
        self._state.prev_replica = None
        self._state.next_replica = None
        if (self._state.replica_id == (len(self._state.replica_list) - 1)):
            self._state.isTail = True
        if (self._state.replica_id == 0):
            self._state.isHead = True
        if (self._state.replica_id < (len(self._state.replica_list) - 1)):
            self._state.next_replica = self._state.replica_list[(self._state.replica_id + 1)]
        if (self._state.replica_id > 0):
            self._state.prev_replica = self._state.replica_list[(self._state.replica_id - 1)]
        self._state.operation_dict = dict()
        self._state.private_key = self._state.private_key
        self._state.public_key_list = self._state.public_key_list
        self._state.cache = dict()

    def run(self):
        while True:
            super()._label('_st_label_762', block=False)

            def ExistentialOpExpr_763():
                for (_, _, (_ConstantPattern783_, _, _, _)) in self._ReplicaReceivedEvent_2:
                    if (_ConstantPattern783_ == 'operation_request'):
                        if True:
                            return True
                return False
            _st_label_762 = 0
            while (_st_label_762 == 0):
                _st_label_762 += 1
                if ExistentialOpExpr_763():
                    _st_label_762 += 1
                else:
                    super()._label('_st_label_762', block=True)
                    _st_label_762 -= 1
            else:
                if (_st_label_762 != 2):
                    continue
            if (_st_label_762 != 2):
                break

    def handleNewRequest(self, request_id, request, client):
        max_slot = 0
        for (s, _, _, _, order_statement_list) in self._state.history:
            if (s >= max_slot):
                max_slot = s
        if (len(self._state.history) == 0):
            slot = 0
        else:
            slot = (max_slot + 1)
        order_proof = []
        result_proof = []
        (result, order_statement) = self.applyOperation(slot, request_id, request)
        order_proof.append(order_statement)
        result_proof.append((result, order_statement, self._state.replica_id))
        print('APPLIED')
        if (not (self._state.isTail == True)):
            print('NOT TAIL')
            self.send(('shuttle', order_proof, result_proof, request_id, slot, request, client, self._id), to=self._state.next_replica)
        else:
            self.send(('operation_result', request_id, 'OK', result_proof, self._id), to=client)
        print('NO REPLY')

    def applyOperation(self, slot, request_id, request):
        result = self.findAndPerformOperation(self._state.operation_dict, request)
        order_statement = self.orderCommandTransition(slot, request_id, request)
        self._state.cache[request_id] = result
        return (result, order_statement)

    def orderCommandTransition(self, slot, request_id, request):
        if (not (self._state.mode == 'ACTIVE')):
            return None
        order_statement = ('order', slot, request_id, request)
        self._state.history.append((slot, request_id, request, self._state.replica_id, [order_statement]))
        return order_statement

    def findAndPerformOperation(self, operation_dict, request):
        if (request[0] == 'p'):
            operands = re.findall("put\\('(.*?)'\\,'(.*?)'\\)", request, re.DOTALL)
            print(operands)
            for (key, val) in operands:
                operation_dict[key] = val
                return 'OK'
        elif (request[0] == 'g'):
            operand = re.findall("get\\('(.*?)'\\)", request)
            for o in operand:
                if (o in operation_dict):
                    return operation_dict.get(o)
                else:
                    return ' '
        elif (request[0] == 'a'):
            operands = re.findall("append\\('(.*?)'\\,'(.*?)'\\)", request, re.DOTALL)
            for (key, val) in operands:
                if (key in operation_dict):
                    operation_dict[key] += val
                    return 'OK'
                else:
                    return 'fail'
        elif (request[0] == 's'):
            operands = re.findall("slice\\('(.*?)','([0-9]+):([0-9]+)'\\)", request)
            for (key, low_index, up_index) in operands:
                if ((key in operation_dict) and (int(low_index) in range(len(operation_dict[key]))) and (int(up_index) in range(len(operation_dict[key])))):
                    operation_dict[key] = operation_dict[key][int(low_index):int(up_index)]
                    return 'OK'
                else:
                    return 'fail'

    def _Replica_handler_279(self, request_id, request_type, request, client):
        if (request_type == 'new'):
            if (self._state.isHead == True):
                print('NEW REQ')
                self.handleNewRequest(request_id, request, client)
    _Replica_handler_279._labels = None
    _Replica_handler_279._notlabels = None

    def _Replica_handler_510(self, order_proof, result_proof, request_id, slot, request, client):
        (result, order_statement) = self.applyOperation(slot, request_id, request)
        order_proof.append(order_statement)
        result_proof.append((result, order_statement, self._state.replica_id))
        if (self._state.isTail == True):
            self.send(('operation_result', request_id, 'OK', result_proof, self._id), to=client)
        else:
            self.send(('shuttle', order_proof, result_proof, request_id, slot, request, client, self._id), to=self._state.next_replica)
    _Replica_handler_510._labels = None
    _Replica_handler_510._notlabels = None
