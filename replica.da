##	Things not done:
##	1. applying operation 
## 	2. signing of statements
## 	3. hashing of statements
## 	4. check validity of order proof and result proof	
## 	5. validate result shuttle
##	6. cache data structure

import re
from nacl.bindings.utils import sodium_memcmp
import nacl.encoding
import nacl.signing
import nacl.hash
import time

class Replica(process):
	def setup(replica_id, isHead, isTail, prev_replica, next_replica, head, history,
			mode, signing_key, verify_key_list, client_verify_key_list, timeout, failures):
		self.operation_dict = dict()
		self.cache = dict()
		#self.count = 0
		self.HASHER = nacl.hash.sha256
		output("\nReplica:", replica_id, "with history: ", history, "initialized", sep = " ")
				
	#1. replica p receives operation request from replica client
	def receive(msg = ('operation_request', request_id, request_type, request, signed_msg, _), from_ = client):
		# verify client signature and validate request message
		try:
			client_key = nacl.signing.VerifyKey(self.client_verify_key_list[request_id[0]], encoder=nacl.encoding.HexEncoder)
			client_key.verify(signed_msg)
		except nacl.exceptions.BadSignatureError:
			output("\nMessage from client is not validated.")
			return
			
		message = signed_msg.message
		if ("request<" + str(request_id) + "," + request + ">") != message.decode():
			output("\nMessage from client is not validated.")
			return
	
		output("\nReplica", self.replica_id, "received", request_type, "operation request", 
			request_id, "for operation:", request, sep = " ") 
			
		if (request_type == 'new'):
			if(self.isHead == True):
				handleNewRequest(request_id, request, client)
				
		elif (request_type == 'retransmission'):
			if (request_id in self.cache.keys() 
					and len(self.cache[request_id]) == 2):
				# replica has cached the result and result proof for the given request id
				print("exist in cache")
				send(('operation_result', request_id, cache[request_id][0], cache[request_id][2], self), to = client)
				output("Replica ", self.replica_id, "sent operation_result", request_id[1], "to client", request_id[0], "from cache", sep = " ")
				
			#elif self.mode == "IMMUTABLE":
			#	response_type = "error"
			#	send((request_id, NULL, response_type), to= client)	
			else:
				if (self.isHead == True):
					if request_id in self.cache.keys(): 
						# head has ordered operation but not received result shuttle yet
						print("exist in head cache")
						if (await(
								some(received(('result_shuttle', result_shuttle_id, result, result_proof, client), 
									from_= self.next_replica), 
								has = (result_shuttle_id == request_id)))):
							output("Replica ", self.replica_id, "received result_shuttle", result_shuttle_id, "from", self.next_replica, sep = " ")
							send(('operation_result', request_id, result, result_proof, self), to = client)
						#elif timeout(t):
						# handle timeout, send reconfiguration request to Olympus
					else: 
						# head doesnt recognize operation, it's a new operation
						print("new request")
						handleNewRequest(request_id, request, client)
						if (await(
								some(received(('result_shuttle', result_shuttle_id, result, result_proof, client), 
									from_= self.next_replica), 
								has = (result_shuttle_id == request_id)))): 
							output("Replica ", self.replica_id, "received result_shuttle", result_shuttle_id, "from", self.next_replica, sep = " ")
							send(('operation_result', request_id, result, result_proof, self), to = client)
						#elif timeout:
						# handle timeout, send reconfiguration request to Olympus
				else: # replica that receives retransmission is not head
					send(('operation_request', request_id, request_type, client), to = self.head)
					output("Replica ", self.replica_id, "sent operation_result", request_id[1], "to head", sep = " ")
					if (await(
							some(received(('result_shuttle', result_shuttle_id, result, result_proof, _), 
								from_ = self.next_replica), 
							has = (result_shuttle_id == request_id)))):
						output("Replica ", self.replica_id, "sent operation_result", request_id[1], "to client", request_id[0], sep = " ")
						# receive result shuttle, send to client
						send(('operation_result', request_id, result, result_proof, self), to = client)
					#elif timeout(t):
					# handle timeout, send reconfiguration request to Olympus

	def handleNewRequest(request_id, request, client):
		# find the max slot that has been assigned to get the slot to assign
		max_slot = 0
		for (s, _, _, _) in self.history:
			if(s >= max_slot):
				max_slot = s
		if len(self.history) == 0:
			slot = 0
		else:
			slot = max_slot + 1
		
		# create empty lists for order proof and result proof
		order_proof = []
		result_proof = []
    
		# get result and signed order statement of the request
		(result, signed_order_stmt) = applyOperation(slot, request_id, request, order_proof)
		
		# hash and sign the result along with request id and request
		result_in_bytes = bytes(result, 'utf-8')
		hash_result = self.HASHER(result_in_bytes, encoder = nacl.encoding.HexEncoder)
		result_stmt_msg = 'result<' + str(request_id) + ',' + request + '>'
		signed_result = self.signing_key.sign(hash_result + result_stmt_msg.encode())
		
		# add signed order statement and result statement to order proof and result proof
		order_proof.append(signed_order_stmt)
		result_proof.append(signed_result)
		
		if self.isTail != True:
			# send shuttle to next replica
			send(('shuttle', order_proof, result_proof, request_id, slot, request, client, self), to = self.next_replica)
			output("Replica ", self.replica_id, "sent shuttle", request_id, "to ", self.next_replica, sep = " ")
		else:
			# if there is only 1 replica in the chain, send result to client directly
			send(('operation_result', request_id, request, result, result_proof, self), to = client)
			output("Replica ", self.replica_id, "sent operation_result", request_id[1], "to client", request_id[0], sep = " ")
	
	def applyOperation(slot, request_id, request, order_proof):
		"""
		Perform condition checks then run the request
		"""
		
		# this replica must be in ACTIVE mode
		if(self.mode != 'ACTIVE'):
			return None

		# check if there is any conflict in current request and history of this replica
		# the slot number shouldn't have been assigned to any other request
		if slot in [t[0] for t in self.history]:
			return None
	
		#check for hole
		for checking_slot in range(slot):
			if checking_slot not in [t[0] for t in self.history]:
				output('Error with replica', self.replica_id, ': hole exists at index', slot, sep= ' ')
				return None
			
	
		#checkpointing -- not needed for phase 2
		
		# validate order proof from shuttle
		# check if all replicas preceding this replica have signed order statement and have correct slot and request id
		for index in range(self.replica_id):
			signed_order_stmt = order_proof[index]
			# verify the signature
			try:
				verify_key = nacl.signing.VerifyKey(self.verify_key_list[index], encoder=nacl.encoding.HexEncoder)
				verify_key.verify(signed_order_stmt)
			except nacl.exceptions.BadSignatureError:
				return None
		
			# get order statement by decoding message from signed message
			order_stmt = signed_order_stmt.message.decode()
			matches = re.findall("order<(\d+),\((\d+),\s+(\d+)\),(.*?)>", order_stmt)
			# there should only be one match
			if len(matches) != 1:
				return None
			
			# check if there is any conflict in slot number and request id 
			(slot_str, client_id_str, workload_id_str, request_str) = matches[0]
			if (slot != int(slot_str) 
					or request_id[0] != int(client_id_str) 
					or request_id[1] != int(workload_id_str)
					or request != request_str):
				return None

		# apply operation in the request to the dictionary object
		result = findAndPerformOperation(request)
		
		if result == None:
			return None
	
		# get order statement of current replica
		current_signed_order_stmt = orderCommand(slot, request_id, request, order_proof)
	
		self.cache[request_id] =  (result, request)
		
		return (result, current_signed_order_stmt)
		
	def findAndPerformOperation(request):
		"""
		Perform the operation in the request
		"""
		
		request = request.strip()
		if request.startswith('put'):
			# put operation
			operands = re.findall("put\(\'(.*?)\'\,\'(.*?)\'\)", request, re.DOTALL)
			# there should only be one tuple of operands found
			if len(operands) != 1:
				return None
				
			(key, val) = operands[0]
			self.operation_dict[key] = val
			return 'OK'
		elif request.startswith('get'):
			# get operation
			operand = re.findall('get\(\'(.*?)\'\)', request)
			# there should only be one operand found
			if len(operand) != 1:
				return None

			o = operand[0]
			if o in self.operation_dict:
				return self.operation_dict.get(o)
			else:
				return ""
		elif request.startswith('append'):
			# append operation
			operands = re.findall('append\(\'(.*?)\'\,\'(.*?)\'\)', request, re.DOTALL)
			# there should only be one tuple of operands found
			if len(operands) != 1:
				return None
			
			(key, val) = operands[0]
			if key in self.operation_dict:
				self.operation_dict[key] += val
				return 'OK'
			else:
				return 'fail'
		elif request.startswith('slice'):
			# slice operation
			operands = re.findall('slice\(\'(.*?)\',\'(\d+):(\d+)\'\)', request)
			# there should only be one tuple of operands found
			if len(operands) != 1:
				return None
				
			(key, low_index, up_index) = operands[0]
			if (key in self.operation_dict 
					and int(low_index) in range(len(self.operation_dict[key])) 
					and int(up_index) in range(len(self.operation_dict[key]))):
				self.operation_dict[key] = self.operation_dict[key][(int)(low_index):(int)(up_index)]
				return 'OK'
			else:
				return 'fail'
		else:
			return None

	def orderCommand(slot, request_id, request, order_proof):
		"""
		Create a signed order statement and create an order proof to append to history of this replica
		"""
		# create an order statement for this replica
		# make order statement a string so it can be turned into bytes and signed 
		order_statement = "order<" + str(slot) + "," + str(request_id) + "," + request + ">"
		# sign order statement using the signing key of this replica
		signed_order_stmt = self.signing_key.sign(order_statement.encode())
		
		# add order statement from previous replicas to order proof
		current_order_proof = order_proof[:self.replica_id]
		current_order_proof.append(signed_order_stmt)
		#print('this the order proof')
		#print(current_order_proof)
		
		# add the signed order statement to 
		self.history.append((slot, request_id, request, current_order_proof))
		return signed_order_stmt
    
	#2. replica receives shuttle
	def receive(msg =('shuttle', order_proof, result_proof, request_id, slot, request, client, _), from_= self.prev_replica):
		output("Replica ", self.replica_id, "received shuttle", request_id, "from", self.prev_replica, sep = " ")
		(result, signed_order_stmt) = applyOperation(slot, request_id, request, order_proof)
		
		# hash and sign the result along with request id and request
		result_in_bytes = bytes(result, 'utf-8')
		hash_result = self.HASHER(result_in_bytes, encoder = nacl.encoding.HexEncoder)
		result_stmt_msg = 'result<' + str(request_id) + ',' + request + '>'
		signed_result = self.signing_key.sign(hash_result + result_stmt_msg.encode())
		
		# add signed order statement and result statement to order proof and result proof
		order_proof.append(signed_order_stmt)
		result_proof.append(signed_result)
		
		if self.isTail == True:
			output("Replica ", self.replica_id, "sent operation_result", request_id, "to client", client, sep = " ")
			send(('operation_result', request_id, request, result, result_proof, self), to = client)
			output("Replica ", self.replica_id, "sent result_shuttle", request_id, "to replica", self.prev_replica, sep = " ")
			send(('result_shuttle', request_id, request, result, result_proof, self), to = self.prev_replica)
		else:
			output("Replica ", self.replica_id, "sent shuttle", request_id, "to", self.next_replica, sep = " ")
			send(('shuttle', order_proof, result_proof, request_id, slot, request, client, self), to = self.next_replica)

	#3. replica p receives result shuttle
	def receive(msg =('result_shuttle', result_shuttle_id, request, result, result_proof, _), from_ = self.next_replica):
		output("Replica ", self.replica_id, "received result_shuttle", result_shuttle_id, "from", self.next_replica, sep = " ")
		# validate result shuttle
		# check if current replica has signed a result statement in the result shuttle
		signed_result_stmt = result_proof[self.replica_id]
		
		# verify the signature
		try:
			verify_key = nacl.signing.VerifyKey(self.verify_key_list[self.replica_id], encoder=nacl.encoding.HexEncoder)
			verify_key.verify(signed_result_stmt)
		except nacl.exceptions.BadSignatureError:
			output("\nReplica", self.replica_id, 
				": message received from result shuttle is not validated, signature doesn't match.", sep = " ")
			return
			
		# validate sign message
		result_message = signed_result_stmt.message
		result_stmt_hash = result_message[:64]
		message = result_message[64:]
		if ('result<' + str(result_shuttle_id) + ',' + request + '>') != message.decode():
			output("\nReplica", self.replica_id, 
				": message received from result shuttle is not validated, request doesn't match.", sep = " ")
			return
		
		# check if current replica has processed the request id from result shuttle
		if result_shuttle_id not in self.cache:
			output("\nReplica", self.replica_id, ": request", result_shuttle_id, "does not exist in cache.", sep = " ")
			return
		
		# check if the request matches for the request id
		if self.cache[result_shuttle_id][1] != request:
			output("\nReplica", self.replica_id, ": request", result_shuttle_id, "for operation", request,			
				"does not match existing operation", self.cache[result_shuttle_id], "in cache.", sep = " ")
			return
			
		# check if hashes match
		result_in_bytes = bytes(self.cache[result_shuttle_id][0], 'utf-8')
		result_hash = self.HASHER(result_in_bytes, encoder = nacl.encoding.HexEncoder)
		if not sodium_memcmp(result_hash, result_stmt_hash):
			# hash does not match
			output("\nReplica", self.replica_id, ": hash of result for request", result_shuttle_id, "for operation", request,			
				"does not match hash in result statement.", sep = " ")
			return

		# cache result proof along with corresponding request id and result
		self.cache[result_shuttle_id] = (result, request, result_proof)
		
		# send result shuttle to previous replica
		if self.isHead == False:
			output("\nReplica ", self.replica_id, "sent result_shuttle", result_shuttle_id, "to", self.prev_replica, sep = " ")
			send(('result_shuttle', result_shuttle_id, request, result, result_proof, self), to= self.prev_replica) 	

	##4. replica receives wedge request -- not needed for phase 2
	##def receive(wedge_statement, from_= Olympus
    #
	##5. replica receives checkpoint proof -- not needed for phase 2
	##def receive(checkpoint_shuttle, from_ = replica)
    #
	##6. replica receives catch up message -- not needed for phase 2
	##def receive("catch_up", from_= Olympus)
    #
	##7. replica receives a get running state message -- not needed for phase 2
	##def receive("get_running_state", from_= Olympus)
	
	def run():
		output('\nStarting replica', self.replica_id, sep = " ")
		# terminate when receive terminate message from Olympus
		await(some(received(('terminate', _), from_ = Olympus)))
		
