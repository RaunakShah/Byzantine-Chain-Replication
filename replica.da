##	Things not done:
##	1. applying operation 
## 	2. signing of statements
## 	3. hashing of statements
## 	4. check validity of order proof and result proof	
## 	5. validate result shuttle
##	6. cache data structure

import re
import nacl.encoding
import nacl.signing

class Replica(process):
	def setup(replica_id, replica_list, history, mode, private_key, public_key_list):
		self.isHead = False
		self.isTail = False
		self.prev_replica = None
		self.next_replica = None	
		if replica_id == len(replica_list) - 1:
			self.isTail = True
		if replica_id == 0:
			self.isHead = True
		if replica_id < len(replica_list) - 1:
			self.next_replica = replica_list[replica_id + 1]
		if replica_id > 0:
			self.prev_replica = replica_list[replica_id - 1]
		self.operation_dict = dict()
		self.private_key = private_key
		self.public_key_list = public_key_list
		self.cache = dict()
	
	#1. replica p receives operation request from replica client
	def receive(msg = ('operation_request', request_id, request_type, request, _), from_ = client):
		if (request_type == 'new'):
			if(self.isHead == True):
				print("NEW REQ")
				handleNewRequest(request_id, request, client)
				
	#	elif (request_type == 'retransmission') :
	#		if(request_id, response) in self.cache:
	#			response_type = "result"
	#			send((request_id, response, response_type), to= client)
	#		elif self.mode == "IMMUTABLE":
	#			response_type = "error"
	#			send((request_id, NULL, response_type), to= client)	
	#		else:
	#			if(self.head == True):
	#				if self.cache contains request_id: #head has ordered operation but not received result shuttle yet
	#					await(received((request_id, result_shuttle), from= self.next)) #timeout replica_timeout send reconfig req
	#					send((request_id, result_shuttle, response_type = "result"), to=client)
	#				else: #head doesnt recognize operation
	#					handleNewRequest(request_id, next_request, self, client)	
	#					await(received((request_id, result_shuttle), from= self.next)) #timeout replica_timeout send reconfig req
	#					send((request_id, result_shuttle, response_type = "result"), to=client)
	#			else:
	#			# replica is not head in chain
	#				send((request_id, next_request, request_type, client), to= self.prev)
	#				await(received((request_id, result_shuttle), from= self.next)) #timeout replica_timeout send reconfig req
	#				send((request_id, result_shuttle, response_type = "result"), to=client)
    #
	
	def handleNewRequest(request_id, request, client):
		max_slot = 0
		for (s, _, _, _, order_statement_list) in self.history:
			if(s >= max_slot):
				max_slot = s
		if len(self.history) == 0:
			slot = 0
		else:
			slot = max_slot + 1
		
		#create shuttle
		order_proof = []
		result_proof = []
    
		(result, order_statement) = applyOperation(slot, request_id, request)
		
		order_proof.append(order_statement)
		result_proof.append((result, order_statement, self.replica_id))
		print("APPLIED")	
		if self.isTail != True:
			print("NOT TAIL")
			msg = self.private_key.sign(('shuttle',order_proof, result_proof, request_id, slot, request, client, self))
			send(msg, to= self.next_replica)
			send((self.private_key.sign(('shuttle', order_proof, result_proof, request_id, slot, request, client, self))), to= self.next_replica)
			#send(('shuttle', order_proof, result_proof, request_id, slot, request, client, self), to = self.next_replica)
		else:
			send((self.private_key.sign(('operation_result', request_id, 'OK', result_proof, self))), to=client)
			#send(('operation_result', request_id, 'OK', result_proof, self), to=client)
		print("NO REPLY") 
	

	def applyOperation(slot, request_id, request):
		#check for conflicting tuples -- not needed in phase 2
	#	for (s,o) in replica.state:
	#		if s == slot and o != operation:	
	#			send(reconfiguation_request, to= Olympus)
	#			return NULL
    #
	#	#check for hole -- not needed for phase 2
    #
		#create new pair and add to state
		#slot_operation_pair = (slot, operation)
		#p.state.append(slot_operation_pair)
		#p.checkpoint_index += 1
		
    
		#checkpointing -- not needed for phase 2
		
		#apply operation:
	#	result = 
		result = findAndPerformOperation(self.operation_dict, request) 

		#print("dict after operation:")
		#print(self.operation_dict)	
		order_statement = orderCommandTransition(slot, request_id, request)
	
		self.cache[request_id] =  result
	#	shuttle.order_proof.shuttle_order_statement_list.append(order_statement)
	#	
	#	#sign result statement
    #
	#	shuttle.result_proof.shuttle_result_statement_list.append(result_statement)
    #
		return (result, order_statement)
    
	def orderCommandTransition(slot, request_id, request):
		if(self.mode != 'ACTIVE'):
			return None
	#	#todo: check if all replicas preceding this one have signed order statement in shuttle
    #
	#	for (s,o,p,c,order_statement_list) in p.history: 
	#		if s == slot and o != operation
	#		return NULL
    #
		order_statement = ("order", slot, request_id, request) # need to sign	
	#	shuttle.order_proof.shuttle_order_statement_list.append(current_order_statement)
	#	p.history.append(shuttle.order_proof)
	
		self.history.append((slot, request_id, request, self.replica_id, [order_statement]))
		return order_statement
    
	#2. replica receives shuttle
	def receive(msg =('shuttle', order_proof, result_proof, request_id, slot, request, client, _), from_= self.prev_replica):
		if(nacl.signing.VerifyKey(public_keys_list[self.prev_replica], encoder=nacl.encoding.HexEncoder).verify(msg)):
		
		#check validity of shuttle.order_proof
		#check validity of shuttle.result_proof
		

		#(result, shuttle) = applyOperation(shuttle.order_proof.max_slot, shuttle.order_proof.request, self, shuttle)
    
			(result, order_statement) = applyOperation(slot, request_id, request)
			order_proof.append(order_statement)
			result_proof.append((result, order_statement, self.replica_id))
			if self.isTail == True:
				#send(('operation_result', request_id, 'OK', result_proof, self), to=client)			#result_shuttle.result_proof = shuttle.result_proof
				send((self.private_key.sign('operation_result', request_id, 'OK', result_proof, self)), to=client)			#result_shuttle.result_proof = shuttle.result_proof
				#result_shuttle.id = shuttle.id
				#send(result_shuttle, to= self.prev)
			else:
				#send(('shuttle', order_proof, result_proof, request_id, slot, request, client, self), to= self.next_replica)
				send((self.private_key.sign('shuttle', order_proof, result_proof, request_id, slot, request, client, self)), to= self.next_replica)
    #

	def findAndPerformOperation(operation_dict, request):
		if request[0] == 'p':
			operands = re.findall("put\(\'(.*?)\'\,\'(.*?)\'\)", request, re.DOTALL)
			print(operands)
			for key, val in operands:
				operation_dict[key] = val
				return 'OK'
		elif request[0] == 'g':
			operand = re.findall('get\(\'(.*?)\'\)', request)	
			for o in operand:
				if o in operation_dict:
					return operation_dict.get(o)
				else:
					return " "
		elif request[0] == 'a':
			operands = re.findall('append\(\'(.*?)\'\,\'(.*?)\'\)', request, re.DOTALL)
			for key, val in operands:
				if key in operation_dict:
					operation_dict[key] += val
					return 'OK'
				else:
					return 'fail'
		elif request[0] == 's':
			operands = re.findall('slice\(\'(.*?)\',\'([0-9]+):([0-9]+)\'\)', request)
			for key, low_index, up_index in operands:
				if key in operation_dict and int(low_index) in range(len(operation_dict[key])) and int(up_index) in range(len(operation_dict[key])):
					operation_dict[key] = operation_dict[key][(int)(low_index):(int)(up_index)]
					return 'OK'
				else:
					return 'fail'


	##3. replica p receives result shuttle
	#def receive(result_shuttle, from_=self.next):
	#	#validate result shuttle
	#	
	#	#cache result proof along with corresponding request id and result
	#	for tuple in self.cache:
	#		if result_shuttle.id == tuple[0]:
	#			tuple[2] = result_shuttle
	#	if self.head == False:
	#		send(result_shuttle, to= self.prev)
    #
	##4. replica receives wedge request -- not needed for phase 2
	##def receive(wedge_statement, from_= Olympus
    #
	##5. replica receives checkpoint proof -- not needed for phase 2
	##def receive(checkpoint_shuttle, from_ = replica)
    #
	##6. replica receives catch up message -- not needed for phase 2
	##def receive("catch_up", from_= Olympus)
    #
	##7. replica receives a get running state message -- not needed for phase 2
	##def receive("get_running_state", from_= Olympus)
    #
    #
    #
    #
 	#		
	def run():
		while True:
			await(some(received(('operation_request', _, _, _), from_= _)))
	#	cache = []
	#	checkpoint_index = 0
	#	state = dict()
		
