##	Things not done:
##	1. applying operation 
## 	2. signing of statements
## 	3. hashing of statements
## 	4. check validity of order proof and result proof	
## 	5. validate result shuttle
##	6. cache data structure

import re
from nacl.bindings.utils import sodium_memcmp
import nacl.encoding
import nacl.signing
import nacl.hash
import time

class Replica(process):
	def setup(replica_id, replica_list, history, mode, private_key, public_key_list):
		self.isHead = False
		self.isTail = False
		self.prev_replica = None
		self.next_replica = None	
		if replica_id == len(replica_list) - 1:
			self.isTail = True
		if replica_id == 0:
			self.isHead = True
		if replica_id < len(replica_list) - 1:
			self.next_replica = replica_list[replica_id + 1]
		if replica_id > 0:
			self.prev_replica = replica_list[replica_id - 1]
		self.operation_dict = dict()
		self.private_key = private_key
		self.public_key_list = public_key_list
		self.cache = dict()
		self.count = 0
		self.HASHER = nacl.hash.sha256
		
	#1. replica p receives operation request from replica client
	def receive(msg = ('operation_request', request_id, request_type, request, _), from_ = client):
		if(count==0):
			time.sleep(5)
			count +=1
		if (request_type == 'new'):
			if(self.isHead == True):
				print("NEW REQ")
				handleNewRequest(request_id, request, client)
				
		elif (request_type == 'retransmission') :
			if (request_id in self.cache.keys()) and (len(self.cache[request_id]) == 2):
				send(('operation_result', request_id, cache[request_id][0], cache[request_id][1]), to= client)
	#		elif self.mode == "IMMUTABLE":
	#			response_type = "error"
	#			send((request_id, NULL, response_type), to= client)	
			else:
				if(self.isHead == True):
					if request_id in self.cache.keys(): #head has ordered operation but not received result shuttle yet
						if(await(some(
								received(('result_shuttle', result_shuttle_id, result, result_proof, client), from_= self.next_replica), has = (result_shuttle_id == request_id)))): #timeout replica_timeout send reconfig req
			#				print("RE")
							send(('operation_result', request_id, result, result_proof, self), to=client)
					else: #head doesnt recognize operation
						handleNewRequest(request_id, request, client)	
						if(await(some(received(('result_shuttle', result_shuttle_id, result, result_proof, client), from_= self.next_replica), has = (result_shuttle_id == request_id)))): #timeout replica_timeout send reconfig req
							send(('operation_result', request_id, result, result_proof, self), to=client)
						#elif timeout:
	
				else: #replica that receives retransmission is not head
					send(('operation_request', request_id, request_type, client), to= replica_list[0])
					if(await(some(received(('result_shuttle', result_shuttle_id, result, result_proof, client), from_= self.next_replica), has = (result_shuttle_id == request_id)))): #timeout replica_timeout send reconfig req
						send(('operation_result', request_id, result, result_proof, self), to=client)
					#elif timeout:
    
	
	def handleNewRequest(request_id, request, client):
		max_slot = 0
		for (s, _, _, _, order_statement_list) in self.history:
			if(s >= max_slot):
				max_slot = s
		if len(self.history) == 0:
			slot = 0
		else:
			slot = max_slot + 1
		
		#create shuttle
		order_proof = []
		result_proof = []
    
		(result, order_statement) = applyOperation(slot, request_id, request)
		result_in_bytes = bytes(result, 'utf-8')
		hash_result = self.HASHER(result_in_bytes, encoder = nacl.encoding.HexEncoder)
		order_proof.append(order_statement)
		result_proof.append((hash_result, order_statement, self.replica_id))
		#print("APPLIED")	
		if self.isTail != True:
			#msg = self.private_key.sign(('shuttle',order_proof, result_proof, request_id, slot, request, client, self))
			#send(msg, to= self.next_replica)
			#send((self.private_key.sign(('shuttle', order_proof, result_proof, request_id, slot, request, client, self))), to= self.next_replica)
			send(('shuttle', order_proof, result_proof, request_id, slot, request, client, self), to = self.next_replica)
		else:
			#send((self.private_key.sign(('operation_result', request_id, 'OK', result_proof, self))), to=client)
			send(('operation_result', request_id, result, result_proof, self), to=client)
		#print("NO REPLY") 
	

	def applyOperation(slot, request_id, request):
		#check for conflicting tuples -- not needed in phase 2
	#	for (s,o) in replica.state:
	#		if s == slot and o != operation:	
	#			send(reconfiguation_request, to= Olympus)
	#			return NULL
	
	#check for hole -- not needed for phase 2

		#create new pair and add to state
		#slot_operation_pair = (slot, operation)
		#p.state.append(slot_operation_pair)
		#p.checkpoint_index += 1
		
    
		#checkpointing -- not needed for phase 2
		
		#apply operation:
		result = findAndPerformOperation(self.operation_dict, request) 

		#print("dict after operation:")
		#print(self.operation_dict)	
		order_statement = orderCommandTransition(slot, request_id, request)
	
		self.cache[request_id] =  result
	#	shuttle.order_proof.shuttle_order_statement_list.append(order_statement)
	#	
	#	#sign result statement
    #
	#	shuttle.result_proof.shuttle_result_statement_list.append(result_statement)
    #
		return (result, order_statement)
    
	def orderCommandTransition(slot, request_id, request):
		if(self.mode != 'ACTIVE'):
			return None
	#	#todo: check if all replicas preceding this one have signed order statement in shuttle
    #
	#	for (s,o,p,c,order_statement_list) in p.history: 
	#		if s == slot and o != operation
	#		return NULL
    #
		order_statement = ("order", slot, request_id, request) # need to sign	
	#	shuttle.order_proof.shuttle_order_statement_list.append(current_order_statement)
	#	p.history.append(shuttle.order_proof)
	
		self.history.append((slot, request_id, request, self.replica_id, [order_statement]))
		return order_statement
    
	#2. replica receives shuttle
	def receive(msg =('shuttle', order_proof, result_proof, request_id, slot, request, client, _), from_= self.prev_replica):
		#if(nacl.signing.VerifyKey(public_keys_list[self.prev_replica], encoder=nacl.encoding.HexEncoder).verify(msg)):
		
		#check validity of shuttle.order_proof
		#check validity of shuttle.result_proof
		

		#(result, shuttle) = applyOperation(shuttle.order_proof.max_slot, shuttle.order_proof.request, self, shuttle)
    
		(result, order_statement) = applyOperation(slot, request_id, request)
		result_in_bytes = bytes(result, 'utf-8')
		hash_result = self.HASHER(result_in_bytes, encoder = nacl.encoding.HexEncoder)
		order_proof.append(order_statement)
		result_proof.append((hash_result, order_statement, self.replica_id))
		if self.isTail == True:
			send(('operation_result', request_id, result, result_proof, self), to=client) 
				#send((self.private_key.sign('operation_result', request_id, 'OK', result_proof, self)), to=client)			#result_shuttle.result_proof = shuttle.result_proof
			result_shuttle_id = request_id  
			send(('result_shuttle',result_shuttle_id, result, result_proof,client), to= self.prev_replica)
		else:
			send(('shuttle', order_proof, result_proof, request_id, slot, request, client, self), to= self.next_replica)
				#send((self.private_key.sign('shuttle', order_proof, result_proof, request_id, slot, request, client, self)), to= self.next_replica)
    #

	def findAndPerformOperation(operation_dict, request):
		if request[0] == 'p':
			operands = re.findall("put\(\'(.*?)\'\,\'(.*?)\'\)", request, re.DOTALL)
		#	print(operands)
			for key, val in operands:
				operation_dict[key] = val
				return 'OK'
		elif request[0] == 'g':
			operand = re.findall('get\(\'(.*?)\'\)', request)	
			for o in operand:
				if o in operation_dict:
					return operation_dict.get(o)
				else:
					return " "
		elif request[0] == 'a':
			operands = re.findall('append\(\'(.*?)\'\,\'(.*?)\'\)', request, re.DOTALL)
			for key, val in operands:
				if key in operation_dict:
					operation_dict[key] += val
					return 'OK'
				else:
					return 'fail'
		elif request[0] == 's':
			operands = re.findall('slice\(\'(.*?)\',\'([0-9]+):([0-9]+)\'\)', request)
			for key, low_index, up_index in operands:
				if key in operation_dict and int(low_index) in range(len(operation_dict[key])) and int(up_index) in range(len(operation_dict[key])):
					operation_dict[key] = operation_dict[key][(int)(low_index):(int)(up_index)]
					return 'OK'
				else:
					return 'fail'


	##3. replica p receives result shuttle
	def receive(msg =('result_shuttle', result_shuttle_id, result, result_proof, client), from_=self.next_replica):
	#	#validate result shuttle
	#	
	#	#cache result proof along with corresponding request id and result
		self.cache[result_shuttle_id] = (result, result_proof)		
		#print("CACHED RESULT")
		#print(cache[result_shuttle_id][1])
		if self.isHead == False:
			send(('result_shuttle', result_shuttle_id, result, result_proof, client, self), to= self.prev_replica) 	
#	for tuple in self.cache:
	#		if result_shuttle.id == tuple[0]:
	#			tuple[2] = result_shuttle
	#	if self.head == False:
	#		send(result_shuttle, to= self.prev)
    #
	##4. replica receives wedge request -- not needed for phase 2
	##def receive(wedge_statement, from_= Olympus
    #
	##5. replica receives checkpoint proof -- not needed for phase 2
	##def receive(checkpoint_shuttle, from_ = replica)
    #
	##6. replica receives catch up message -- not needed for phase 2
	##def receive("catch_up", from_= Olympus)
    #
	##7. replica receives a get running state message -- not needed for phase 2
	##def receive("get_running_state", from_= Olympus)
    #
    #
    #
    #
 	#		
	def run():
		while True:
			await(some(received(('operation_request', _, _, _), from_= _)))
	#	cache = []
	#	checkpoint_index = 0
	#	state = dict()
		
