## Changes from psuedocode:
## getConfig() does not take two arguments. Takes only one argument - Olympus
## operation.id and operation.type are now independant variables - id and type
## id and type are parameters to send()
## operation_request does not have any attributes except for the operation itself
## after retransmit, client waits for any type of message (result or error). we need a way to specify whether the message is a result or error message, in the same format, maybe a string "result" or "error"

from nacl.bindings.utils import sodium_memcmp
import nacl.encoding
import nacl.signing
import nacl.hash
import time

class Client(process):
	def setup(client_id, olympus, workload, client_timeout, signing_key, olympus_verify_key):
		# current request id, initialized to be (0,0)
		self.current_request_id = (0,0)
		# current request operation, initialized to be ''
		self.current_request_operation = ''
		# hasher used for hash decoding
		self.HASHER = nacl.hash.sha256
		# current configuration id, initialized to be 0
		self.configuration_id = 0
		# replica chain
		self.chain = []
		# replica verify keys
		self.verify_key_list = []
		# num of majority replicas
		self.majority_num = 0
		# indicate the state of client when client is waiting and verifying response from operation request
		self.response_verified = True
		output("Client ID:", client_id, "\nWorkload:", workload, "\nTimeout:", client_timeout, sep = " ")		
		
	def run():
		output('\nStarting client', self.client_id, sep = " ")
		# get configuration from Olympus
		(self.chain, self.verify_key_list) = getConfig(self.olympus)
		# get num of majority replicas
		self.majority_num = (len(self.chain) - 1) / 2 + 1
		
		check_configuration_msg = 0
		workload_count = 0 
		for request in workload:
			request_type = 'new'
			self.current_request_operation = request
			
			# check configurations with Olympus for every 5 requests from current client
			if workload_count % 5 == 0:
				send(('check_configuration', check_configuration_msg, self), to = self.olympus)
				output("\nClient", self.client_id, ": sent check config message to Olympus.", sep = " ")
				# wait for response from Olympus, in phase 2 Olympus always replies 'OK'
				await(
					some(received(('check_configuration_response', olympus_response, message_id, _), from_= Olympus),
					has = (message_id == check_configuration_msg and olympus_response == 'OK')))
				output("\nClient", self.client_id, ": received check config response: ", olympus_response, sep = " ")
				check_configuration_msg += 1
			
			# request_id is a pair of current client id and current request id in client's workload
			request_id = (client_id, workload_count)
			self.current_request_id = request_id
			
			# create and sign request message
			request_msg = "request<" + str(request_id) + "," + request + ">"
			signed_msg = self.signing_key.sign(request_msg.encode())
			
			# send operation request to head of replica chain
			send(('operation_request', request_id, request_type, request, signed_msg, self), to = self.chain[0])
			output("\nClient", self.client_id, ": sent operation_request", request_id, "to", self.chain[0], sep = " ")

			self.response_verified = False
			
			#if (await(
			#		some(received(('operation_result', result_request_id, request_type, result_request, response, result_proof, _),
			#			from_ = self.chain[len(self.chain) - 1]),
			#		has = (result_request_id == request_id and request_type == 'new')) and is_verified)):
			#	output("\nClient", self.client_id, ": received operation_response of request", request_id,
			#		"for operation", request, sep = " ")
		    #
			#	# verify operation result
			#	if verify(request_id, result_request, response, result_proof):
			#		output("\nClient", self.client_id, ": response of", request_type, "request", request_id, 
			#		"for operation", request, "is validated, the result is:", response, sep = " ")
			#	else:
			#		output("Result not validated")
			#		time.sleep(self.client_timeout)
			
			# wait and verify for response from replica for the current request
			if (await(self.response_verified)):
				pass
			elif timeout(self.client_timeout):
				# if timeout, perform retransmit
				output("\nClient", self.client_id, ": timeout waiting for response for request", request_id, "start retransmission phase", sep = " ")
				retransmit(request_id, request)
				
			# move to next request in client's workload
			workload_count += 1
		
		# after all requests are processed, send terminate message to Olympus
		output("\nClient", self.client_id, "terminating.", sep = " ")
		send(("terminate", self.client_id, self), to = self.olympus)
				
	def verify(request_id, request, response, result_proof):
		# hash() used temporarily for hashing of result
		response_in_bytes = bytes(response, 'utf-8')
		response_hash = self.HASHER(response_in_bytes, encoder = nacl.encoding.HexEncoder)
		
		acceptance_num = 0
		
		# check response hash with all hashes in result proof
		for index in range(len(result_proof)):
			# validate result statement
			signed_result_stmt = result_proof[index]
			
			# verify the signature by the replica
			try:
				verify_key = nacl.signing.VerifyKey(self.verify_key_list[index], encoder=nacl.encoding.HexEncoder)
				verify_key.verify(signed_result_stmt)
			except nacl.exceptions.BadSignatureError:
				output("\nClient", self.client_id, ": result statement for", request_id, 
					"is not validated, signature from replica", index, "doesn't match.", sep = " ")
				continue
				
			# validate sign message
			result_message = signed_result_stmt.message
			
			result_hash = result_message[:64]
			message = result_message[64:]
			if ('result<' + str(request_id) + ',' + request + '>') != message.decode():
				output("\nClient", self.client_id, ": result statement for", request_id, 
					"is not validated, signed message from replica", index, "doesn't match request.", sep = " ")
				continue
			
			# check if hashes match
			if not sodium_memcmp(response_hash, result_hash):
				# hash does not match
				output("\nClient", self.client_id, ": hash of result for request", request_id, 
					"for operation", request, "does not match hash of replica", index, 
					"in result statement.", sep = " ")
				#NOTE: not needed for phase 2; i think we only need to retransmit the request
				#reconfiguration_reqeust.proof_of_misbehavior = (result, result_proof)
				#need to call a receive handler to use new configuration for retransmit
				#send(reconfiguration_request, to= Olympus)
				continue
			
			# increment the acceptance num
			acceptance_num += 1
		
		# if accept majority of replica, response is verified
		if acceptance_num >= self.majority_num:
			output("\nClient", self.client_id, ": response of request", request_id, 
					"for operation", request, "is verified with", acceptance_num, 
					"replicas acceptance.", sep = " ")
			return True
		else:
			output("\nClient", self.client_id, ": response of request", request_id, 
					"for operation", request, "is not verified with", acceptance_num, 
					"replicas acceptance, expected", self.majority_num, "acceptance.", sep = " ")
			return False

	def retransmit(request_id, request):
		request_type = 'retransmission'
		# create and sign request message
		request_msg = "request<" + str(request_id) + "," + request + ">"
		signed_msg = self.signing_key.sign(request_msg.encode())
			
		# send retransmission message to all replicas in the chain
		for replica in chain:
			# send operation request to head of replica chain
			send(('operation_request', request_id, request_type, request, signed_msg, self), to = replica)
			output("\nClient", self.client_id, ": sent retransmission_request", request_id, "to", self.chain[0], sep = " ")
		
		self.response_verified = False
		# wait for response from replica for the retransmission request
		# can receive result and result proof or error statement from a replica
		if (await(self.response_verified)):
			output("\nClient", self.client_id, ": retransmission for request", request_id, "finished.", sep = " ")
		elif timeout(self.client_timeout):
			output("\nClient", self.client_id, ": retransmission for request", request_id, "timeout. (For Phase 2 only since we don't consider reconfig)", sep = " ")
		#elif (response_type == "error"):
		#	chain = getConfig(Olympus)
		#	retransmit(id, retransmit_request, chain.replicas)

	def receive(msg =('operation_result', result_request_id, 'new', result_request, response, result_proof, _), from_ = replica):
		output("\nClient", self.client_id, ": received response for new request", result_request_id, 
			"from replica", replica, sep = " ")
		# check request id, request type, and request
		if (result_request_id != self.current_request_id or result_request != self.current_request_operation):
			return

		# verify operation result
		if verify(result_request_id, result_request, response, result_proof):
			output("\nClient", self.client_id, ": response of new request", result_request_id, 
				"for operation", result_request, "is validated, the result is:", response, sep = " ")
			# result is verified, set verifying state back to false
			self.response_verified = True
			
	def receive(msg =('operation_result', result_request_id, 'retransmission', result_request, response, result_proof, _), from_ = replica):
		output("\nClient", self.client_id, ": received response for retransmission request", result_request_id, 
			"from replica", replica, sep = " ")
		# check request id, request type, and request
		if (result_request_id != self.current_request_id or result_request != self.current_request_operation):
			return

		# verify operation result
		if verify(request_id, result_request, response, result_proof):
			output("\nClient", self.client_id, ": response of", request_type, "request", request_id, 
				"for operation", request, "is validated, the result is:", response, sep = " ")
			self.response_verified = True
		
	def getConfig(Olympus):
		# send get current configuration (replica chain and their verify keys) request to Olympus
		send(('get_configuration', self), to = Olympus)
		
		output("\nClient", self.client_id, ": sent get_configuration to Olympus.", sep = " ")
		if await(
				some(received(('get_configuration_response', olympus_configuration_id, chain, verify_key_list, signed_msg, _), 
				from_= Olympus))):
			output("\nClient", self.client_id, ": received configuration", olympus_configuration_id, "from Olympus.", sep = " ")
			# verify signature and validate message
			try:
				olympus_key = nacl.signing.VerifyKey(self.olympus_verify_key, encoder=nacl.encoding.HexEncoder)
				olympus_key.verify(signed_msg)
			except nacl.exceptions.BadSignatureError:
				output("\nClient", self.client_id, ": message from Olympus is not validated, signature doesn't match.")
				return None
			message = signed_msg.message
			if ('configuration_id:' + str(self.configuration_id)) != message.decode():
				output("\nClient", self.client_id, ": message from Olympus is not validated, mesage doesn't match.")
				return None
			
			return (chain, verify_key_list)
